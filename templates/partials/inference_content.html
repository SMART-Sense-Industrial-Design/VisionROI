
<div class="cam-row">
    <div class="video-col">
        <div class="card roi-card video-card">
            <div id="cam1" class="cam-cell">
                <div class="d-flex align-items-center mb-2 gap-2 menu-select-list">
                    <label for="cam1-sourceSelect" class="form-label mb-0">Source:</label>
                    <select id="cam1-sourceSelect" class="form-select w-auto"></select>
                    <label for="cam1-intervalInput" class="form-label mb-0">Time:</label>
                    <input id="cam1-intervalInput" type="number" class="form-control w-auto" min="0" step="0.1" value="1" />
                </div>
                <button id="cam1-startButton" class="btn btn-primary me-2">Start</button>
                <button id="cam1-stopButton" class="btn btn-danger" disabled>Stop</button>
                <p id="cam1-status"></p>
                <div class="video-wrapper">
                    <img id="cam1-video" class="stream-video" />
                </div>
            </div>
        </div>
        <div class="card roi-card log-card">
            <div class="d-flex align-items-center mb-2 gap-2 menu-select-list">
                <label for="cam1-logRoiSelect" class="form-label mb-0">ROI:</label>
                <select id="cam1-logRoiSelect" class="form-select w-auto"></select>
            </div>
            <div class="log-wrapper">
                <table id="cam1-logTable" class="table">
                    <thead><tr><th>Log</th></tr></thead>
                    <tbody id="cam1-logBody"></tbody>
                </table>
            </div>
        </div>
    </div>
    <div class="card roi-card roi-list-card">
        <div class="d-flex align-items-center mb-2 gap-2 menu-select-list">
            <label for="cam1-groupSelect" class="form-label mb-0">Group:</label>
            <select id="cam1-groupSelect" class="form-select w-auto flex-grow-1" style="min-width:0;"></select>
        </div>
        <div id="cam1-rois" class="roi-grid"></div>
    </div>
</div>
  <script>
      (function() {
      function createCameraController(cellId) {
        let socket;
        let roiSocket;
        let rois = [];
        let allRois = [];
        let running = false;
        const cam = `inf_${cellId}`;
        const getEl = suffix => document.getElementById(`${cellId}-${suffix}`);
        const video = getEl('video');
        video.onload = () => URL.revokeObjectURL(video.src);
        function showBlackScreen() {
            if (video.src && video.src.startsWith('blob:')) {
                URL.revokeObjectURL(video.src);
            }
            video.removeAttribute('src');
            video.style.display = 'none';
        }
        showBlackScreen();
        const startButton = getEl('startButton');
        const stopButton = getEl('stopButton');
        const statusEl = getEl('status');
        const sourceSelect = getEl('sourceSelect');
        const groupSelect = getEl('groupSelect');
        const roiGrid = getEl('rois');
        const logBody = getEl('logBody');
        const logRoiSelect = getEl('logRoiSelect');
        const intervalInput = getEl('intervalInput');
        let logTimer;
        let currentLogSource;
        let frameTimer;
        let lastFrameTime = 0;
        intervalInput.value = localStorage.getItem(`${cellId}-interval`) || '1';

        const formatTs = ts => {
            if (!ts) return '';
            const d = new Date(ts * 1000);
            const ms = String(d.getMilliseconds()).padStart(3, '0');
            return `${d.toLocaleTimeString('th-TH', { hour12: false })}.${ms}`;
        };

        sourceSelect.onchange = () => {
            localStorage.setItem(`${cellId}-source`, sourceSelect.value);
        };

        startButton.onclick = startInference;
        stopButton.onclick = stopInference;
        groupSelect.onchange = switchGroup;
        logRoiSelect.onchange = () => {
            if (currentLogSource) {
                startLogUpdates(currentLogSource);
            }
        };

        async function fetchWithStatus(url, options = {}) {
            statusEl.innerText = 'กำลังโหลด...';
            try {
                const res = await fetch(url, options);
                if (!res.ok) throw new Error('network');
                statusEl.innerText = 'สำเร็จ';
                return res;
            } catch (err) {
                statusEl.innerText = 'เกิดข้อผิดพลาด';
                throw err;
            }
        }

        async function loadSources() {
            try {
                const res = await fetchWithStatus('/source_list');
                if (!res.ok) throw new Error('Bad response');
                const data = await res.json();
                sourceSelect.innerHTML = '';
                if (data.length === 0) {
                    const opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = 'No sources available';
                    sourceSelect.appendChild(opt);
                    statusEl.innerText = 'Create a source first';
                    showAlert('No sources available', 'error');
                } else {
                    data.forEach(item => {
                        const opt = document.createElement('option');
                        opt.value = item.name;
                        opt.textContent = item.name;
                        sourceSelect.appendChild(opt);
                    });
                    const stored = localStorage.getItem(`${cellId}-source`) || '';
                    if (stored) {
                        sourceSelect.value = stored;
                    }
                    showAlert('Sources loaded', 'success');
                }
            } catch (err) {
                console.error('Failed to load sources', err);
                sourceSelect.innerHTML = '';
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Error loading sources';
                sourceSelect.appendChild(opt);
                statusEl.innerText = 'Error fetching sources';
                showAlert('Failed to load sources', 'error');
            }
        }

        function ensureRoiItem(id) {
            if (document.getElementById(`${cellId}-roi-${id}`)) return;
            const r = rois.find(r => r.id === id) || { id };
            const item = document.createElement('div');
            item.className = 'roi-item';
            const title = document.createElement('h4');
            title.className = 'roi-title';
            title.textContent = r.name || `ROI ${id}`;
            const img = document.createElement('img');
            img.id = `${cellId}-roi-${id}`;
            img.className = 'roi-image';
            const p = document.createElement('p');
            p.id = `${cellId}-text-${id}`;
            p.className = 'roi-text';
            const t = document.createElement('p');
            t.id = `${cellId}-time-${id}`;
            t.className = 'roi-time';
            item.appendChild(title);
            item.appendChild(img);
            item.appendChild(p);
            item.appendChild(t);
            roiGrid.appendChild(item);
        }

        function startLogUpdates(sourceName){
            currentLogSource = sourceName;
            stopLogUpdates();
            async function fetchLog(){
                try{
                    const res=await fetch(`/read_log?source=${encodeURIComponent(sourceName)}&lines=40&_=${Date.now()}`);
                    const data=await res.json();
                    const selectedRoi=logRoiSelect.value;
                    logBody.innerHTML='';
                    (data.lines||[]).slice().reverse().forEach(line=>{
                        if(selectedRoi==='all'||line.includes(`roi_id=${selectedRoi}`)){
                            const tr=document.createElement('tr');
                            const td=document.createElement('td');
                            td.textContent=line;
                            tr.appendChild(td);
                            logBody.appendChild(tr);
                        }
                    });
                }catch(e){}
            }
            fetchLog();
            logTimer=setInterval(fetchLog,1000);
        }

        function stopLogUpdates(){
            if(logTimer){clearInterval(logTimer);logTimer=null;}
            logBody.innerHTML='';
        }

        function updateLogRoiOptions(list){
            logRoiSelect.innerHTML='';
            const optAll=document.createElement('option');
            optAll.value='all';
            optAll.textContent='All';
            logRoiSelect.appendChild(optAll);
            list.forEach(r=>{
                const opt=document.createElement('option');
                opt.value=r.id;
                opt.textContent=r.id;
                logRoiSelect.appendChild(opt);
            });
        }

        function loadGroupOptions(list, selected = '') {
            groupSelect.innerHTML = '';
            const optSelect = document.createElement('option');
            optSelect.value = '';
            optSelect.textContent = '-- Select --';
            groupSelect.appendChild(optSelect);
            const optAll = document.createElement('option');
            optAll.value = 'all';
            optAll.textContent = 'All';
            groupSelect.appendChild(optAll);
            const groups = Array.from(
                new Set(
                    list
                        .filter(r => (r.type ?? 'roi') === 'roi')
                        .map(r => r.group ?? r.page ?? r.name)
                        .filter(p => p)
                )

            );
            groups.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p;
                opt.textContent = p;
                groupSelect.appendChild(opt);
            });
            const stored = selected || localStorage.getItem(`${cellId}-group`) || '';
            groupSelect.value = stored;
            const roiForLog = stored && stored !== 'all'
                ? list.filter(r => (r.group ?? r.page ?? r.name) === stored)
                : list;
            updateLogRoiOptions(roiForLog);
        }

        async function startInference(roisOverride = null, selectedGroup = '') {
            if (running) return;
            running = true;
            startButton.disabled = true;
            const name = sourceSelect.value;
            if (!name) {
                statusEl.innerText = 'Select source first';
                running = false;
                startButton.disabled = false;
                showAlert('Select source first', 'error');
                return;
            }
            localStorage.setItem(`${cellId}-source`, name);

            const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
            const cfg = await cfgRes.json();

            const { module: _unused, rois: roiPathRaw, ...camCfg } = cfg;
            const interval = parseFloat(intervalInput.value) || 1;
            localStorage.setItem(`${cellId}-interval`, interval);
            let roiPath = roiPathRaw;
            if (!roiPath.startsWith('/')) {
                roiPath = `data_sources/${cfg.name}/${roiPath}`;
            }
            const res = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
            const data = await res.json();
            statusEl.innerText = 'Loaded: ' + data.filename;
            allRois = data.rois || [];
            const roiList = allRois.filter(r => (r.type ?? 'roi') === 'roi');
            if (selectedGroup) {
                localStorage.setItem(`${cellId}-group`, selectedGroup);
            } else {
                localStorage.removeItem(`${cellId}-group`);
            }
            loadGroupOptions(roiList, selectedGroup);
            rois = roisOverride || (selectedGroup && selectedGroup !== 'all'
                ? roiList.filter(r => (r.group ?? r.page ?? r.name) === selectedGroup)
                : selectedGroup === 'all'
                    ? roiList

                    : []);
            roiGrid.innerHTML = '';

            let startData;
            let startRes;
            statusEl.innerText = 'กำลังโหลด...';
            try {
                startRes = await fetch(`/start_inference/${cam}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ ...camCfg, rois, group: selectedGroup, interval })
                });
                startData = await startRes.json().catch(() => ({}));
            } catch (err) {
                running = false;
                startButton.disabled = false;
                statusEl.innerText = 'เกิดข้อผิดพลาด';
                showAlert('Failed to start inference stream', 'error');
                return;
            }
            if (!startRes.ok || (startData.status !== 'started' && startData.status !== 'already_running')) {
                running = false;
                startButton.disabled = false;
                statusEl.innerText = 'เกิดข้อผิดพลาด';
                if (startData.message === 'open_failed') {
                    showAlert('Failed to open video source', 'error');
                } else {
                    showAlert('Failed to start inference stream', 'error');
                }
                return;
            }
            statusEl.innerText = 'สำเร็จ';
            openSocket();
            if (rois.length > 0) {
                openRoiSocket();
                showAlert('Inference started', 'success');
            } else {
                showAlert('Camera started', 'success');
            }
            startLogUpdates(cfg.name);
            setRunningUI();
        }

        async function stopInference() {
            if (!running) return;
            running = false;
            await fetchWithStatus(`/stop_inference/${cam}`, { method: 'POST' });
            if (socket) {
                socket.close();
                socket = null;
            }
            if (roiSocket) {
                roiSocket.close();
                roiSocket = null;
            }
            if (frameTimer) {
                clearInterval(frameTimer);
                frameTimer = null;
            }
            stopLogUpdates();
            // clear last frame and related data to free memory
            showBlackScreen();
            rois = [];
            allRois = [];
            roiGrid.innerHTML = '';
            statusEl.innerText = 'Stopped';
            startButton.innerText = 'Resume';
            startButton.disabled = false;
            stopButton.disabled = true;
            showAlert('Inference stopped', 'info');
        }

        function openSocket() {
            socket = new WebSocket(`ws://${location.host}/ws/${cam}`);
            socket.binaryType = 'arraybuffer';
            lastFrameTime = Date.now();
            socket.onmessage = function(event) {
                lastFrameTime = Date.now();
                if (video.src && video.src.startsWith('blob:')) {
                    URL.revokeObjectURL(video.src);
                }
                const blob = new Blob([event.data], { type: 'image/jpeg' });
                if (video.style.display === 'none') {
                    video.style.display = '';
                }
                video.src = URL.createObjectURL(blob);
            };
            socket.onclose = () => {
                showBlackScreen();
                if (frameTimer) {
                    clearInterval(frameTimer);
                    frameTimer = null;
                }
            };
            frameTimer = setInterval(() => {
                if (Date.now() - lastFrameTime > 2000) {
                    showBlackScreen();
                    try { socket.close(); } catch (e) {}
                    openSocket();
                }
            }, 1000);
        }

        function openRoiSocket() {
            roiSocket = new WebSocket(`ws://${location.host}/ws_roi_result/${cam}`);
            roiSocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    if (Object.prototype.hasOwnProperty.call(data, 'id')) {
                        setTimeout(() => {
                            ensureRoiItem(data.id);
                            const imgEl = document.getElementById(`${cellId}-roi-${data.id}`);
                            if (imgEl) {
                                imgEl.src = `data:image/jpeg;base64,${data.image}`;
                            }
                            const textEl = document.getElementById(`${cellId}-text-${data.id}`);
                            if (textEl) {
                                textEl.textContent = `OCR: ${data.text || ''}`;
                            }
                            const timeEl = document.getElementById(`${cellId}-time-${data.id}`);
                            if (timeEl) {
                                const frameTs = formatTs(data.frame_time);
                                timeEl.textContent = `เวลา: ${frameTs}`;
                            }
                        }, 0);
                    }
                } catch (e) {
                    console.error('ROI message error', e);
                }
            };
        }

        async function checkStatus() {
            const name = sourceSelect.value;
            const res = await fetchWithStatus(`/inference_status/${cam}`);
            const data = await res.json();
            if (data.running && name) {
                openSocket();
                const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
                const cfg = await cfgRes.json();
                let roiPath = cfg.rois;
                if (!roiPath.startsWith('/')) {
                    roiPath = `data_sources/${cfg.name}/${roiPath}`;
                }
                const roiRes = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
                const roiData = await roiRes.json();
                allRois = roiData.rois || [];
                const roiList = allRois.filter(r => (r.type ?? 'roi') === 'roi');
                loadGroupOptions(roiList);
                const stored = groupSelect.value;
                rois = stored === 'all'
                    ? roiList
                    : stored
                        ? roiList.filter(r => (r.group ?? r.page ?? r.name) === stored)

                        : [];
                const interval = parseFloat(intervalInput.value) || 1;
                await fetchWithStatus(`/start_inference/${cam}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rois, group: stored, interval })
                });
                if (rois.length > 0) {
                    roiGrid.innerHTML = '';
                    openRoiSocket();
                }
                startLogUpdates(cfg.name);
                setRunningUI();
                running = true;
            } else {
                statusEl.innerText = 'Idle';
                startButton.innerText = 'Start';
                startButton.disabled = false;
                stopButton.disabled = true;
                running = false;
                stopLogUpdates();
            }
        }

        async function switchGroup() {
            const selected = groupSelect.value;
            if (!selected) return;
            localStorage.setItem(`${cellId}-group`, selected);
            const roiList = allRois.filter(r => (r.type ?? 'roi') === 'roi');
            const filtered = selected === 'all'
                ? roiList
                : roiList.filter(r => (r.group ?? r.page ?? r.name) === selected);

            updateLogRoiOptions(filtered);

            await stopInference();
            await startInference(filtered, selected);
        }

        function setRunningUI() {
            statusEl.innerText = 'Running';
            startButton.disabled = true;
            stopButton.disabled = false;
            startButton.innerText = 'Start';
        }

        (async () => {
            await loadSources();
            await checkStatus();
        })();

        return { stopInference };
    }

  // initialize controllers immediately (DOMContentLoaded already fired in fragments)
  const controllers = [
      createCameraController('cam1')
  ];
  })();
  </script>
