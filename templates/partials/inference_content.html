<h2>Inference with Saved ROI</h2>
<p>Modules are defined in the ROI file.</p>
<div class="cam-row">
    <div class="card">
        <div id="cam1" class="cam-cell">
            <select id="cam1-sourceSelect" class="form-select mb-2"></select>
            <button id="cam1-startButton" class="btn btn-primary me-2">Start</button>
            <button id="cam1-stopButton" class="btn btn-danger" disabled>Stop</button>
            <p id="cam1-status"></p>
            <div class="video-wrapper">
                <img id="cam1-video" width="320" height="240" />
                <canvas id="cam1-overlay" class="overlay-canvas" width="320" height="240"></canvas>
            </div>
            <div id="cam1-pageResult" class="page-result">
                <img id="cam1-pageRef" />
                <img id="cam1-pageSnap" />
                <p id="cam1-pageScore" class="page-result-score"></p>
            </div>
        </div>
    </div>
    <div class="card roi-card">
        <div id="cam1-rois" class="roi-grid"></div>
    </div>
</div>
  <script>
      (function() {
      function createCameraController(cellId) {
        let socket;
        let roiSocket;
        let rois = [];
        let allRois = [];
        let running = false;
        const cam = cellId.replace(/\D/g, '');
        const getEl = suffix => document.getElementById(`${cellId}-${suffix}`);
        const video = getEl('video');
        const overlay = getEl('overlay');
        const overlayCtx = overlay.getContext('2d');
        const pageRef = getEl('pageRef');
        const pageSnap = getEl('pageSnap');
        const pageScore = getEl('pageScore');
        let currentPagePoints = null;
        video.onload = () => {
            overlay.width = video.naturalWidth || video.width;
            overlay.height = video.naturalHeight || video.height;
            drawPageBox(currentPagePoints);
            URL.revokeObjectURL(video.src);
        };
        const startButton = getEl('startButton');
        const stopButton = getEl('stopButton');
        const statusEl = getEl('status');
        const sourceSelect = getEl('sourceSelect');
        const roiGrid = getEl('rois');
        let pageRois = [];

        startButton.onclick = startInference;
        stopButton.onclick = stopInference;

        async function fetchWithStatus(url, options = {}) {
            statusEl.innerText = 'กำลังโหลด...';
            try {
                const res = await fetch(url, options);
                if (!res.ok) throw new Error('network');
                statusEl.innerText = 'สำเร็จ';
                return res;
            } catch (err) {
                statusEl.innerText = 'เกิดข้อผิดพลาด';
                throw err;
            }
        }

        async function loadSources() {
            try {
                const res = await fetchWithStatus('/source_list');
                if (!res.ok) throw new Error('Bad response');
                const data = await res.json();
                sourceSelect.innerHTML = '';
                if (data.length === 0) {
                    const opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = 'No sources available';
                    sourceSelect.appendChild(opt);
                    statusEl.innerText = 'Create a source first';
                    showAlert('No sources available', 'error');
                } else {
                    data.forEach(item => {
                        const opt = document.createElement('option');
                        opt.value = item.name;
                        opt.textContent = item.name;
                        sourceSelect.appendChild(opt);
                    });
                    showAlert('Sources loaded', 'success');
                }
            } catch (err) {
                console.error('Failed to load sources', err);
                sourceSelect.innerHTML = '';
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Error loading sources';
                sourceSelect.appendChild(opt);
                statusEl.innerText = 'Error fetching sources';
                showAlert('Failed to load sources', 'error');
            }
        }

        function renderRoiPlaceholders(list = rois) {
            roiGrid.innerHTML = '';
            list.forEach(r => {
                const item = document.createElement('div');
                item.className = 'roi-item';
                const title = document.createElement('h4');
                title.className = 'roi-title';
                title.textContent = r.name || `ROI ${r.id}`;
                const img = document.createElement('img');
                img.id = `${cellId}-roi-${r.id}`;
                img.className = 'roi-image';
                const p = document.createElement('p');
                p.id = `${cellId}-text-${r.id}`;
                p.className = 'roi-text';
                item.appendChild(title);
                item.appendChild(img);
                item.appendChild(p);
                roiGrid.appendChild(item);
            });
        }

        function drawPageBox(points) {
            overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
            currentPagePoints = points || null;
            if (!points) return;
            overlayCtx.strokeStyle = 'lime';
            overlayCtx.lineWidth = 2;
            overlayCtx.beginPath();
            overlayCtx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                overlayCtx.lineTo(points[i].x, points[i].y);
            }
            overlayCtx.closePath();
            overlayCtx.stroke();
        }

        function showPageResult(ref, snap, score) {
            if (ref && snap) {
                pageRef.src = ref;
                pageSnap.src = snap;
                pageScore.textContent = 'Score: ' + score.toFixed(2);
            } else {
                pageRef.src = '';
                pageSnap.src = '';
                pageScore.textContent = '';
            }
        }

        async function detectPage(blob, pages) {
            if (!pages.length) return null;
            const img = await createImageBitmap(blob);
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            let best = null;
            for (const p of pages) {
                const xs = p.points.map(pt => pt.x);
                const ys = p.points.map(pt => pt.y);
                const x = Math.min(...xs);
                const y = Math.min(...ys);
                const w = Math.max(...xs) - x;
                const h = Math.max(...ys) - y;
                if (w <= 0 || h <= 0) continue;
                const snapCanvas = document.createElement('canvas');
                snapCanvas.width = w;
                snapCanvas.height = h;
                const snapCtx = snapCanvas.getContext('2d');
                snapCtx.drawImage(canvas, x, y, w, h, 0, 0, w, h);
                const snapData = snapCtx.getImageData(0, 0, w, h);
                const refImg = new Image();
                refImg.src = `data:image/jpeg;base64,${p.image}`;
                await refImg.decode();
                const refCanvas = document.createElement('canvas');
                refCanvas.width = w;
                refCanvas.height = h;
                const refCtx = refCanvas.getContext('2d');
                refCtx.drawImage(refImg, 0, 0, w, h);
                const refData = refCtx.getImageData(0, 0, w, h);
                let diff = 0;
                const d1 = snapData.data;
                const d2 = refData.data;
                for (let i = 0; i < d1.length; i += 4) {
                    diff += Math.abs(d1[i] - d2[i]) +
                            Math.abs(d1[i + 1] - d2[i + 1]) +
                            Math.abs(d1[i + 2] - d2[i + 2]);
                }
                diff = diff / (w * h);
                if (!best || diff < best.score) {
                    best = {
                        page: p.page,
                        points: p.points,
                        ref: `data:image/jpeg;base64,${p.image}`,
                        snap: snapCanvas.toDataURL('image/jpeg'),
                        score: diff
                    };
                }
            }
            return best;
        }

        async function startInference() {
            if (running) return;
            running = true;
            startButton.disabled = true;
            const name = sourceSelect.value;
            if (!name) {
                statusEl.innerText = 'Select source first';
                running = false;
                startButton.disabled = false;
                showAlert('Select source first', 'error');
                return;
            }
            const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
            const cfg = await cfgRes.json();
            const { module: _unused, rois: roiPathRaw, ...camCfg } = cfg;
            let roiPath = roiPathRaw;
            if (!roiPath.startsWith('/')) {
                roiPath = `data_sources/${cfg.name}/${roiPath}`;
            }
            await fetchWithStatus(`/start_inference/${cam}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ ...camCfg, rois: [] })
            });
            openSocket();
            const res = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
            const data = await res.json();
            statusEl.innerText = 'Loaded: ' + data.filename;
            allRois = data.rois || [];
            pageRois = allRois.filter(r => (r.type ?? 'roi') === 'page' && r.image);
            const roiCandidates = allRois.filter(r => r.module);
            let page = '';
            if (pageRois.length > 0) {
                try {
                    const snapRes = await fetchWithStatus(`/ws_snapshot/${cam}`);
                    const blob = await snapRes.blob();
                    const pageInfo = await detectPage(blob, pageRois);
                    if (pageInfo) {
                        page = pageInfo.page;
                        statusEl.innerText = 'Detected page: ' + page;
                        drawPageBox(pageInfo.points);
                        showPageResult(pageInfo.ref, pageInfo.snap, pageInfo.score);
                    } else {
                        drawPageBox();
                        showPageResult();
                    }
                } catch (e) {
                    console.error('Page detection failed', e);
                    drawPageBox();
                    showPageResult();
                }
            } else {
                drawPageBox();
                showPageResult();
            }
            rois = roiCandidates.filter(r => !page || r.page === page);
            await fetchWithStatus(`/start_inference/${cam}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ rois })
            });
            if (rois.length > 0) {
                renderRoiPlaceholders();
                openRoiSocket();
                showAlert('Inference started', 'success');
            } else {
                roiGrid.innerHTML = '';
                showAlert('Camera started', 'success');
            }
            setRunningUI();
        }

        async function stopInference() {
            if (!running) return;
            running = false;
            await fetchWithStatus(`/stop_inference/${cam}`, { method: 'POST' });
            if (socket) {
                socket.close();
                socket = null;
            }
            if (roiSocket) {
                roiSocket.close();
                roiSocket = null;
            }
            // clear last frame and update UI
            video.src = '';
            roiGrid.innerHTML = '';
            drawPageBox();
            showPageResult();
            statusEl.innerText = 'Stopped';
            startButton.innerText = 'Resume';
            startButton.disabled = false;
            stopButton.disabled = true;
            showAlert('Inference stopped', 'info');
        }

        function openSocket() {
            socket = new WebSocket(`ws://${location.host}/ws/${cam}`);
            socket.binaryType = 'arraybuffer';
            socket.onmessage = function(event) {
                const blob = new Blob([event.data], { type: 'image/jpeg' });
                video.src = URL.createObjectURL(blob);
            };
        }

        function openRoiSocket() {
            roiSocket = new WebSocket(`ws://${location.host}/ws_roi_result/${cam}`);
            roiSocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    const imgEl = document.getElementById(`${cellId}-roi-${data.id}`);
                    if (imgEl) {
                        imgEl.src = `data:image/jpeg;base64,${data.image}`;
                    }
                    const textEl = document.getElementById(`${cellId}-text-${data.id}`);
                    if (textEl) {
                        textEl.textContent = data.text || '';
                    }
                } catch (e) {
                    console.error('ROI message error', e);
                }
            };
        }

        async function checkStatus() {
            const name = sourceSelect.value;
            const res = await fetchWithStatus(`/inference_status/${cam}`);
            const data = await res.json();
            if (data.running && name) {
                openSocket();
                const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
                const cfg = await cfgRes.json();
                let roiPath = cfg.rois;
                if (!roiPath.startsWith('/')) {
                    roiPath = `data_sources/${cfg.name}/${roiPath}`;
                }
                const roiRes = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
                const roiData = await roiRes.json();
                allRois = roiData.rois || [];
                pageRois = allRois.filter(r => (r.type ?? 'roi') === 'page' && r.image);
                const roiCandidates = allRois.filter(r => r.module);
                let page = '';
                if (pageRois.length > 0) {
                    try {
                        const snapRes = await fetchWithStatus(`/ws_snapshot/${cam}`);
                        const blob = await snapRes.blob();
                        const pageInfo = await detectPage(blob, pageRois);
                        if (pageInfo) {
                            page = pageInfo.page;
                            statusEl.innerText = 'Detected page: ' + page;
                            drawPageBox(pageInfo.points);
                            showPageResult(pageInfo.ref, pageInfo.snap, pageInfo.score);
                        } else {
                            drawPageBox();
                            showPageResult();
                        }
                    } catch (e) {
                        console.error('Page detection failed', e);
                        drawPageBox();
                        showPageResult();
                    }
                } else {
                    drawPageBox();
                    showPageResult();
                }
                rois = roiCandidates.filter(r => !page || r.page === page);
                await fetchWithStatus(`/start_inference/${cam}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rois })
                });
                if (rois.length > 0) {
                    renderRoiPlaceholders();
                    openRoiSocket();
                }
                setRunningUI();
                running = true;
            } else {
                statusEl.innerText = 'Idle';
                startButton.innerText = 'Start';
                startButton.disabled = false;
                stopButton.disabled = true;
                running = false;
            }
        }

        function setRunningUI() {
            statusEl.innerText = 'Running';
            startButton.disabled = true;
            stopButton.disabled = false;
            startButton.innerText = 'Start';
        }

        (async () => {
            await loadSources();
            await checkStatus();
        })();

        return { stopInference };
    }

  // initialize controllers immediately (DOMContentLoaded already fired in fragments)
  const controllers = [
      createCameraController('cam1')
  ];
  })();
  </script>
