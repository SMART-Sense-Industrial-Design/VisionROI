
<div class="d-flex flex-column gap-3">
  <div class="d-flex align-items-start justify-content-between flex-wrap gap-3">
    <div>
      <h4 class="mb-1">จัดการงาน Inference แบบ Dynamic</h4>
      <p class="mb-0 text-muted">เพิ่ม ลบ หรือดูสถานะของงาน Inference ได้ตามต้องการ ระบบจะสร้างงานใหม่ให้ใช้งานทันที</p>
    </div>
    <div class="d-flex gap-2 flex-wrap">
      <button type="button" id="addInferenceBtn" class="btn btn-success">เพิ่มงาน Inference</button>
    </div>
  </div>
  
  <div id="inferenceRows" class="d-flex flex-column gap-4"></div>
</div>
  <script>
      (function() {
      function initRoiLayout(cellId) {
        const videoCell = document.getElementById(cellId);
        const videoCol = videoCell ? videoCell.closest('.video-col') : null;
        const roiContainer = document.getElementById(`${cellId}-rois`);
        const roiCard = roiContainer ? roiContainer.closest('.roi-list-card') : null;
        if (!videoCol || !roiCard) {
          return;
        }

        const roiGrid = roiCard.querySelector('.roi-grid');
        if (roiGrid) {
          roiGrid.style.height = '100%';
        }

        const updateHeight = () => {
          const rect = videoCol.getBoundingClientRect();
          if (rect && rect.height) {
            roiCard.style.maxHeight = `${rect.height}px`;
          }
        };

        updateHeight();

        if ('ResizeObserver' in window) {
          const observer = new ResizeObserver(() => updateHeight());
          observer.observe(videoCol);
        }

        window.addEventListener('resize', updateHeight);
      }

      function createCameraController(cellId, options = {}) {
        let socket;
        let roiSocket;
        let socketReconnectTimer;
        let roiSocketReconnectTimer;
        let socketReconnectAttempts = 0;
        let roiSocketReconnectAttempts = 0;
        const INITIAL_RECONNECT_DELAY = 500;
        const MAX_RECONNECT_DELAY = 10000;
        const computeReconnectDelay = attempt => {
          const step = Math.max(1, attempt);
          const delay = INITIAL_RECONNECT_DELAY * Math.pow(2, step - 1);
          return Math.min(MAX_RECONNECT_DELAY, delay);
        };
        let rois = [];
        let allRois = [];
        let running = false;
        let streamActive = false;
        const FRAME_TIMEOUT_MS = 5000;
        let frameWatchdogTimer;
        const {
          camId: camIdOverride,
          title: providedTitle,
          defaultSource: providedSource,
          defaultInterval,
          defaultGroup,
        } = options || {};
        const cam = typeof camIdOverride === 'string' && camIdOverride.length > 0
          ? camIdOverride
          : `inf_${cellId}`;
        const storageNamespace = `inference-group:${cam}`;
        const makeStorageKey = suffix => `${storageNamespace}:${suffix}`;
        const readStoredValue = suffix => localStorage.getItem(makeStorageKey(suffix));
        const storeValue = (suffix, value) => {
          if (value === undefined || value === null || value === '') {
            localStorage.removeItem(makeStorageKey(suffix));
          } else {
            localStorage.setItem(makeStorageKey(suffix), value);
          }
        };
        const migrateLegacyKey = (legacySuffix, newSuffix = legacySuffix) => {
          const legacyKey = `${cellId}-${legacySuffix}`;
          const legacyValue = localStorage.getItem(legacyKey);
          if (legacyValue !== null && readStoredValue(newSuffix) === null) {
            storeValue(newSuffix, legacyValue);
          }
          if (legacyValue !== null) {
            localStorage.removeItem(legacyKey);
          }
        };
        ['source', 'interval', 'group'].forEach(key => migrateLegacyKey(key));
        const getEl = suffix => document.getElementById(`${cellId}-${suffix}`);
        const video = getEl('video');
        const videoWrapper = video ? video.closest('.video-wrapper') : null;
        const supportsImageBitmap = typeof window !== 'undefined'
          && typeof createImageBitmap === 'function';
        const bitmapRendererCtx = supportsImageBitmap && video && typeof video.getContext === 'function'
          ? video.getContext('bitmaprenderer')
          : null;
        const canUseBitmapRenderer = Boolean(
          bitmapRendererCtx && typeof bitmapRendererCtx.transferFromImageBitmap === 'function'
        );
        const videoCtx = canUseBitmapRenderer
          ? bitmapRendererCtx
          : (video && typeof video.getContext === 'function'
            ? video.getContext('2d')
            : null);
        let allowBitmapDecoding = supportsImageBitmap;
        let fallbackImgEl;
        let fallbackObjectUrl;
        const startButton = getEl('startButton');
        const stopButton = getEl('stopButton');
        const statusEl = getEl('status');
        const titleEl = getEl('title');
        const labelEl = getEl('label');
        const sourceSelect = getEl('sourceSelect');
        const groupSelect = getEl('groupSelect');
        const roiGrid = getEl('rois');
        const logBody = getEl('logBody');
        const logRoiSelect = getEl('logRoiSelect');
        const intervalInput = getEl('intervalInput');
        let logTimer;
        const clearTimeoutSafe = timer => {
          if (typeof timer === 'number') {
            clearTimeout(timer);
          }
        };
        const revokeFallbackUrl = () => {
          if (fallbackObjectUrl) {
            URL.revokeObjectURL(fallbackObjectUrl);
            fallbackObjectUrl = null;
          }
        };

        const clearFrameWatchdog = () => {
          clearTimeoutSafe(frameWatchdogTimer);
          frameWatchdogTimer = undefined;
        };

        const scheduleFrameWatchdog = wsInstance => {
          if (FRAME_TIMEOUT_MS <= 0 || !running || socket !== wsInstance) {
            return;
          }
          clearFrameWatchdog();
          frameWatchdogTimer = setTimeout(() => {
            frameWatchdogTimer = undefined;
            if (!running || socket !== wsInstance) {
              return;
            }
            streamActive = false;
            if (statusEl) {
              statusEl.innerText = 'ไม่พบภาพจากกล้อง กำลังเชื่อมต่อใหม่...';
            }
            try {
              wsInstance.close(4000, 'frame_timeout');
            } catch (err) {
              console.warn('Stream watchdog close failed', err);
            }
          }, FRAME_TIMEOUT_MS);
        };

        const hideFallbackImage = () => {
          if (fallbackImgEl) {
            fallbackImgEl.style.display = 'none';
            fallbackImgEl.removeAttribute('src');
          }
          if (video) {
            video.style.display = '';
          }
          revokeFallbackUrl();
        };

        const clearCanvas = () => {
          hideFallbackImage();
          if (!video) {
            return;
          }
          if (canUseBitmapRenderer) {
            video.width = 0;
            video.height = 0;
          } else if (videoCtx && typeof videoCtx.clearRect === 'function') {
            videoCtx.clearRect(0, 0, video.width || 0, video.height || 0);
          }
        };

        const queueFrameForRender = (() => {
          if (!videoCtx) {
            return () => {};
          }
          let pendingFrame = null;
          let isRendering = false;

          const getDisplaySize = (width, height) => {
            if (!video) {
              return { width, height };
            }

            const wrapperRect = videoWrapper && typeof videoWrapper.getBoundingClientRect === 'function'
              ? videoWrapper.getBoundingClientRect()
              : null;
            const containerWidth = wrapperRect && wrapperRect.width
              ? wrapperRect.width
              : (video.parentElement?.clientWidth || 0);
            const widthLimit = containerWidth > 0 ? containerWidth : Math.min(width, 1280);
            const viewportLimit = typeof window !== 'undefined' && window.innerHeight
              ? Math.max(320, window.innerHeight * 0.6)
              : height;
            const heightLimit = Math.min(height, viewportLimit);
            const scale = Math.min(
              1,
              widthLimit > 0 ? widthLimit / width : 1,
              heightLimit > 0 ? heightLimit / height : 1,
            );
            const targetWidth = Math.max(1, Math.round(width * scale));
            const targetHeight = Math.max(1, Math.round(height * scale));
            return { width: targetWidth, height: targetHeight };
          };

          const applyDisplaySize = (targetWidth, targetHeight) => {
            if (!video) {
              return;
            }
            if (video.width !== targetWidth) {
              video.width = targetWidth;
            }
            if (video.height !== targetHeight) {
              video.height = targetHeight;
            }
            if (video.style.width !== `${targetWidth}px`) {
              video.style.width = `${targetWidth}px`;
            }
            if (video.style.height !== `${targetHeight}px`) {
              video.style.height = `${targetHeight}px`;
            }
          };

          const ensureFallbackImage = () => {
            if (fallbackImgEl) {
              return fallbackImgEl;
            }
            if (!videoWrapper) {
              return null;
            }
            const img = document.createElement('img');
            img.id = `${cellId}-video-fallback`;
            img.className = video ? video.className : 'stream-video';
            img.alt = 'Stream preview';
            img.style.display = 'none';
            videoWrapper.appendChild(img);
            fallbackImgEl = img;
            return fallbackImgEl;
          };

          const renderWithFallbackImage = async blob => {
            const imgEl = ensureFallbackImage();
            if (!imgEl) {
              return;
            }
            if (video) {
              video.style.display = 'none';
            }
            imgEl.style.display = '';
            revokeFallbackUrl();
            await new Promise((resolve, reject) => {
              const objectUrl = URL.createObjectURL(blob);
              fallbackObjectUrl = objectUrl;
              imgEl.onload = () => {
                URL.revokeObjectURL(objectUrl);
                fallbackObjectUrl = null;
                resolve();
              };
              imgEl.onerror = err => {
                URL.revokeObjectURL(objectUrl);
                fallbackObjectUrl = null;
                reject(err);
              };
              imgEl.src = objectUrl;
            });
          };

          const processNext = async () => {
            if (!pendingFrame) {
              isRendering = false;
              return;
            }
            isRendering = true;
            const blob = pendingFrame;
            pendingFrame = null;
            let bitmap;
            try {
              if (allowBitmapDecoding && typeof createImageBitmap === 'function') {
                hideFallbackImage();
                bitmap = await createImageBitmap(blob);
                if (!bitmap) {
                  throw new Error('empty_bitmap');
                }
                const width = bitmap.width || 0;
                const height = bitmap.height || 0;
                const { width: targetWidth, height: targetHeight } = getDisplaySize(width, height);
                applyDisplaySize(targetWidth, targetHeight);
                if (canUseBitmapRenderer && typeof videoCtx.transferFromImageBitmap === 'function') {
                  videoCtx.transferFromImageBitmap(bitmap);
                } else if (
                  videoCtx
                  && typeof videoCtx.clearRect === 'function'
                  && typeof videoCtx.drawImage === 'function'
                ) {
                  videoCtx.clearRect(0, 0, targetWidth, targetHeight);
                  videoCtx.drawImage(bitmap, 0, 0, targetWidth, targetHeight);
                }
              } else {
                await renderWithFallbackImage(blob);
              }
            } catch (err) {
              console.error('Failed to render frame', err);
              if (allowBitmapDecoding) {
                allowBitmapDecoding = false;
                try {
                  await renderWithFallbackImage(blob);
                } catch (fallbackErr) {
                  console.error('Fallback render failed', fallbackErr);
                }
              }
            } finally {
              if (bitmap && typeof bitmap.close === 'function') {
                bitmap.close();
              }
              if (pendingFrame) {
                processNext();
              } else {
                isRendering = false;
              }
            }
          };

          return blob => {
            if (!blob) {
              pendingFrame = null;
              hideFallbackImage();
              streamActive = false;
              return;
            }
            pendingFrame = blob;
            if (!isRendering) {
              processNext();
            }
          };
        })();

        let isLogUpdating = false;
        let logSessionId = 0;
        let currentLogSource;
        const baseTitle = typeof providedTitle === 'string' && providedTitle.length > 0
          ? providedTitle
          : 'งาน Inference';
        if (titleEl) {
          titleEl.textContent = baseTitle;
        }
        const baseLabelText = `ID: ${cam}`;
        if (labelEl) {
          labelEl.textContent = baseLabelText;
        }
        const storedInterval = readStoredValue('interval');
        if (storedInterval) {
          intervalInput.value = storedInterval;
        } else if (defaultInterval !== undefined && defaultInterval !== null) {
          intervalInput.value = String(defaultInterval);
        } else {
          intervalInput.value = '1';
        }
        const normalizedDefaultGroup = typeof defaultGroup === 'string' ? defaultGroup : '';
        const getStoredGroup = () => {
          const stored = readStoredValue('group');
          if (stored !== null) {
            return stored;
          }
          return normalizedDefaultGroup;
        };
        const storeGroupSelection = value => {
            if (value) {
                storeValue('group', value);
            } else {
                storeValue('group', null);
            }
        };
        let lastActiveGroup = getStoredGroup();

        const formatTs = ts => {
            if (!ts) return '';
            const d = new Date(ts * 1000);
            const ms = String(d.getMilliseconds()).padStart(3, '0');
            return `${d.toLocaleTimeString('th-TH', { hour12: false })}.${ms}`;
        };

        const formatDuration = seconds => {
            if (!Number.isFinite(seconds) || seconds < 0) return '';
            if (seconds >= 1) {
                return `${seconds.toFixed(2)} s`;
            }
            if (seconds >= 0.001) {
                return `${Math.round(seconds * 1000)} ms`;
            }
            return `${(seconds * 1000).toFixed(2)} ms`;
        };

        const updateHeaderSourceLabel = () => {
            if (!labelEl) {
                return;
            }
            const sourceName = sourceSelect.value || '';
            labelEl.textContent = sourceName
                ? `${baseLabelText} • Source: ${sourceName}`
                : baseLabelText;
        };

        sourceSelect.onchange = () => {
            storeValue('source', sourceSelect.value);
            updateHeaderSourceLabel();
        };

        startButton.onclick = () => { startInference(); };
        stopButton.onclick = () => { stopInference(); };
        groupSelect.onchange = () => { switchGroup(); };
        logRoiSelect.onchange = () => {
            if (currentLogSource) {
                startLogUpdates(currentLogSource);
            }
        };

        async function fetchWithStatus(url, options = {}) {
            statusEl.innerText = 'กำลังโหลด...';
            try {
                const res = await fetch(url, options);
                if (!res.ok) throw new Error('network');
                statusEl.innerText = 'สำเร็จ';
                return res;
            } catch (err) {
                statusEl.innerText = 'เกิดข้อผิดพลาด';
                throw err;
            }
        }

        async function loadSources() {
            try {
                const res = await fetchWithStatus('/source_list');
                if (!res.ok) throw new Error('Bad response');
                const data = await res.json();
                sourceSelect.innerHTML = '';
                if (data.length === 0) {
                    const opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = 'No sources available';
                    sourceSelect.appendChild(opt);
                    statusEl.innerText = 'Create a source first';
                    showAlert('No sources available', 'error');
                } else {
                    data.forEach(item => {
                        const opt = document.createElement('option');
                        opt.value = item.name;
                        opt.textContent = item.name;
                        sourceSelect.appendChild(opt);
                    });
                    const stored = readStoredValue('source') || '';
                    const preferredSource = stored
                        || (typeof providedSource === 'string' ? providedSource : '');
                    const availableSources = new Set(data.map(item => item.name));
                    if (preferredSource && availableSources.has(preferredSource)) {
                        sourceSelect.value = preferredSource;
                        storeValue('source', preferredSource);
                    }
                    updateHeaderSourceLabel();
                    showAlert('Sources loaded', 'success');
                }
            } catch (err) {
                console.error('Failed to load sources', err);
                sourceSelect.innerHTML = '';
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'Error loading sources';
                sourceSelect.appendChild(opt);
                statusEl.innerText = 'Error fetching sources';
                showAlert('Failed to load sources', 'error');
                updateHeaderSourceLabel();
            }
        }

        const getModuleElementId = id => `${cellId}-module-${id}`;

        function findRoiDataById(id) {
            const key = String(id);
            const match = rois.find(r => String(r?.id) === key);
            if (match) return match;
            return allRois.find(r => String(r?.id) === key) || null;
        }

        function normalizeModule(value) {
            return typeof value === 'string' ? value.trim() : '';
        }

        function updateRoiModuleLabel(id, override = '') {
            const moduleEl = document.getElementById(getModuleElementId(id));
            if (!moduleEl) return;
            const overrideText = normalizeModule(override);
            const fallback = normalizeModule(findRoiDataById(id)?.module ?? '');
            const moduleName = overrideText || fallback;
            moduleEl.textContent = moduleName ? `โมดูล: ${moduleName}` : 'โมดูล: -';
        }

        function isRoiType(data) {
            return (data?.type ?? 'roi') === 'roi';
        }

        function normalizeGroupName(value) {
            return typeof value === 'string' ? value.trim() : '';
        }

        function getRoiGroupName(roi) {
            return normalizeGroupName(roi?.group ?? roi?.page ?? roi?.name ?? '');
        }

        function roiMatchesActiveGroup(data) {
            if (!isRoiType(data)) {
                return false;
            }
            const activeGroup = normalizeGroupName(lastActiveGroup);
            if (!activeGroup) {
                return rois.some(r => String(r?.id) === String(data?.id));
            }
            if (activeGroup === 'all') {
                return true;
            }
            return getRoiGroupName(data) === activeGroup;
        }

        function ensureRoiItem(id, roiData = null) {
            if (document.getElementById(`${cellId}-roi-${id}`)) return;
            const key = String(id);
            const r =
                roiData
                || rois.find(entry => String(entry?.id) === key)
                || findRoiDataById(id)
                || null;
            if (!r || !roiMatchesActiveGroup(r)) {
                return;
            }
            const item = document.createElement('div');
            item.className = 'roi-item';
            const title = document.createElement('h4');
            title.className = 'roi-title';
            title.textContent = r.name || `ROI ${id}`;
            const img = document.createElement('img');
            img.id = `${cellId}-roi-${id}`;
            img.className = 'roi-image';
            const moduleLine = document.createElement('p');
            moduleLine.id = getModuleElementId(id);
            moduleLine.className = 'roi-module';
            const t = document.createElement('p');
            t.id = `${cellId}-time-${id}`;
            t.className = 'roi-time';
            const p = document.createElement('p');
            p.id = `${cellId}-text-${id}`;
            p.className = 'roi-text';
            item.appendChild(title);
            item.appendChild(img);
            item.appendChild(moduleLine);
            item.appendChild(t);
            item.appendChild(p);
            roiGrid.appendChild(item);
            updateRoiModuleLabel(id);
        }

        function applyRoiResult(result, fallbackFrameTime) {
            if (!result) return;
            const roiId = result.id;
            if (roiId === undefined || roiId === null) return;
            const roiData = findRoiDataById(roiId);
            if (!roiData || !roiMatchesActiveGroup(roiData)) {
                return;
            }
            ensureRoiItem(roiId, roiData);
            updateRoiModuleLabel(roiId, result.module);
            const imgEl = document.getElementById(`${cellId}-roi-${roiId}`);
            if (imgEl && Object.prototype.hasOwnProperty.call(result, 'image')) {
                imgEl.src = result.image ? `data:image/jpeg;base64,${result.image}` : '';
            }
            const textEl = document.getElementById(`${cellId}-text-${roiId}`);
            if (textEl) {
                const text = result.text ?? '';
                textEl.textContent = text ? `ข้อความ: ${text}` : 'ข้อความ: -';
            }
            const timeEl = document.getElementById(`${cellId}-time-${roiId}`);
            if (timeEl) {
                const duration = typeof result.duration === 'number'
                    ? result.duration
                    : Number.NaN;
                const durationText = formatDuration(duration);
                if (durationText) {
                    timeEl.textContent = `เวลา: ${durationText}`;
                } else {
                    const ts = typeof result.frame_time === 'number'
                        ? result.frame_time
                        : fallbackFrameTime;
                    timeEl.textContent = ts ? `เวลา: ${formatTs(ts)}` : '';
                }
            }
        }

        function startLogUpdates(sourceName){
            currentLogSource = sourceName;
            stopLogUpdates();
            const sessionId = logSessionId;
            isLogUpdating = true;
            async function fetchLog(){
                if(!isLogUpdating || sessionId !== logSessionId){
                    return;
                }
                try{
                    const res=await fetch(`/read_log?source=${encodeURIComponent(sourceName)}&lines=40&_=${Date.now()}`);
                    const data=await res.json();
                    if(sessionId !== logSessionId){
                        return;
                    }
                    const selectedRoi=logRoiSelect.value;
                    logBody.innerHTML='';
                    const lines=(data.lines||[]).slice().reverse();
                    lines.forEach(line=>{
                        const marker='AGGREGATED_ROI ';
                        const idx=line.indexOf(marker);
                        if(idx!==-1){
                            const prefix=line.slice(0,idx).trim();
                            const payload=line.slice(idx+marker.length).trim();
                            try{
                                const parsed=JSON.parse(payload);
                                const results=Array.isArray(parsed.results)?parsed.results:[];
                                const frameTs=typeof parsed.frame_time==='number'?parsed.frame_time:null;
                                const resultTs=typeof parsed.result_time==='number'?parsed.result_time:null;
                                const groupLabel=parsed.group||'';
                                results.forEach(res=>{
                                    const roiId=res?.id??res?.roi_id??res?.ROI_ID;
                                    if(roiId===undefined||roiId===null)return;
                                    if(selectedRoi!=='all'&&String(roiId)!==selectedRoi)return;
                                    const tr=document.createElement('tr');
                                    const td=document.createElement('td');
                                    const parts=[];
                                    if(prefix)parts.push(prefix);
                                    if(frameTs)parts.push(`frame=${formatTs(frameTs)}`);
                                    if(resultTs)parts.push(`result=${formatTs(resultTs)}`);
                                    parts.push(`roi_id=${roiId}`);
                                    if(res.name)parts.push(`name=${res.name}`);
                                    const moduleName=typeof res.module==='string'?res.module.trim():'';
                                    if(moduleName)parts.push(`module=${moduleName}`);
                                    if(groupLabel)parts.push(`group=${groupLabel}`);
                                    if(typeof res.duration==='number'){
                                        const dur=formatDuration(res.duration);
                                        if(dur)parts.push(`duration=${dur}`);
                                    }
                                    const textValue=typeof res.text==='string'?res.text:'';
                                    parts.push(`text=${textValue}`);
                                    td.textContent=parts.join(' | ');
                                    tr.appendChild(td);
                                    logBody.appendChild(tr);
                                });
                                return;
                            }catch(e){}
                        }
                        if(selectedRoi==='all'||line.includes(`roi_id=${selectedRoi}`)){
                            const tr=document.createElement('tr');
                            const td=document.createElement('td');
                            td.textContent=line;
                            tr.appendChild(td);
                            logBody.appendChild(tr);
                        }
                    });
                }catch(e){}
                finally{
                    if(isLogUpdating && sessionId === logSessionId){
                        logTimer=setTimeout(fetchLog,1000);
                    }
                }
            }
            fetchLog();
        }

        function stopLogUpdates(){
            isLogUpdating=false;
            logSessionId++;
            if(logTimer){
                clearTimeout(logTimer);
                logTimer=null;
            }
            logBody.innerHTML='';
        }

        function updateLogRoiOptions(list){
            logRoiSelect.innerHTML='';
            const optAll=document.createElement('option');
            optAll.value='all';
            optAll.textContent='All';
            logRoiSelect.appendChild(optAll);
            list.forEach(r=>{
                const opt=document.createElement('option');
                opt.value=r.id;
                opt.textContent=r.id;
                logRoiSelect.appendChild(opt);
            });
        }

        function loadGroupOptions(list, selected) {
            groupSelect.innerHTML = '';
            const optSelect = document.createElement('option');
            optSelect.value = '';
            optSelect.textContent = '-- Select --';
            groupSelect.appendChild(optSelect);
            const optAll = document.createElement('option');
            optAll.value = 'all';
            optAll.textContent = 'All';
            groupSelect.appendChild(optAll);
            const groups = Array.from(
                new Set(
                    list
                        .filter(r => (r.type ?? 'roi') === 'roi')
                        .map(r => r.group ?? r.page ?? r.name)
                        .filter(p => p)
                )

            );
            groups.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p;
                opt.textContent = p;
                groupSelect.appendChild(opt);
            });
            const stored = getStoredGroup();
            const hasSelected = typeof selected === 'string' && selected.length > 0;
            const requested = hasSelected ? selected : stored;
            const validGroups = new Set(groups);
            const currentSelection = (requested === 'all' || validGroups.has(requested)) ? requested : '';
            groupSelect.value = currentSelection;
            storeGroupSelection(currentSelection);
            const roiForLog = currentSelection
                ? currentSelection === 'all'
                    ? list
                    : list.filter(r => (r.group ?? r.page ?? r.name) === currentSelection)
                : [];
            updateLogRoiOptions(roiForLog);
            return currentSelection;
        }

        async function startInference(roisOverride = null, selectedGroup = '') {
            if (running) return;
            running = true;
            streamActive = false;
            startButton.disabled = true;
            const name = sourceSelect.value;
            if (!name) {
                statusEl.innerText = 'Select source first';
                running = false;
                startButton.disabled = false;
                showAlert('Select source first', 'error');
                return;
            }
        storeValue('source', name);

        const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
        const cfg = await cfgRes.json();

            const { module: _unused, rois: roiPathRaw, ...camCfg } = cfg;
        const interval = parseFloat(intervalInput.value) || 1;
        storeValue('interval', interval);
            let roiPath = roiPathRaw;
            if (!roiPath.startsWith('/')) {
                roiPath = `data_sources/${cfg.name}/${roiPath}`;
            }
            const res = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
            const data = await res.json();
            statusEl.innerText = '';
            allRois = data.rois || [];
            const roiList = allRois.filter(r => (r.type ?? 'roi') === 'roi');
            const fallbackGroup = lastActiveGroup || '';
            const selectedGroupName = typeof selectedGroup === 'string' && selectedGroup.length > 0
                ? selectedGroup
                : fallbackGroup;
            if (!selectedGroupName) {
                storeGroupSelection('');
            }
            const activeGroup = loadGroupOptions(roiList, selectedGroupName);
            const groupToUse = selectedGroupName || activeGroup;
            const requestGroup = groupToUse || null;
            lastActiveGroup = groupToUse || '';
            if (Array.isArray(roisOverride)) {
                rois = roisOverride;
            } else if (groupToUse === 'all') {
                rois = roiList;
            } else if (groupToUse) {
                rois = roiList.filter(r => (r.group ?? r.page ?? r.name) === groupToUse);
            } else {
                rois = [];
            }
            roiGrid.innerHTML = '';
            rois.forEach(r => {
                if (r && r.id !== undefined && r.id !== null) {
                    ensureRoiItem(r.id, r);
                    updateRoiModuleLabel(r.id);
                }
            });

            let startData;
            let startRes;
            statusEl.innerText = 'กำลังโหลด...';
            try {
                startRes = await fetch(`/start_inference/${cam}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        ...camCfg,
                        rois,
                        group: requestGroup,
                        interval,
                        draw_page_boxes: false
                    })
                });
                startData = await startRes.json().catch(() => ({}));
            } catch (err) {
                running = false;
                startButton.disabled = false;
                statusEl.innerText = 'เกิดข้อผิดพลาด';
                showAlert('Failed to start inference stream', 'error');
                return;
            }
            if (!startRes.ok || (startData.status !== 'started' && startData.status !== 'already_running')) {
                running = false;
                startButton.disabled = false;
                statusEl.innerText = 'เกิดข้อผิดพลาด';
                if (startData.message === 'open_failed') {
                    showAlert('Failed to open video source', 'error');
                } else {
                    showAlert('Failed to start inference stream', 'error');
                }
                return;
            }
            statusEl.innerText = 'กำลังรับสตรีมภาพ...';
            openSocket();
            if (rois.length > 0) {
                openRoiSocket();
                showAlert('Inference started', 'success');
            } else {
                showAlert('Camera started', 'success');
            }
            const logSourceName = cfg.name || name;
            startLogUpdates(logSourceName);
            setRunningUI();
        }

        const resetSocketReconnect = () => {
            socketReconnectAttempts = 0;
            clearTimeoutSafe(socketReconnectTimer);
            socketReconnectTimer = undefined;
        };

        const resetRoiSocketReconnect = () => {
            roiSocketReconnectAttempts = 0;
            clearTimeoutSafe(roiSocketReconnectTimer);
            roiSocketReconnectTimer = undefined;
        };

        const scheduleSocketReconnect = () => {
            if (!running) {
                return;
            }
            socketReconnectAttempts += 1;
            const delay = computeReconnectDelay(socketReconnectAttempts);
            clearTimeoutSafe(socketReconnectTimer);
            streamActive = false;
            statusEl.innerText = 'เชื่อมต่อภาพใหม่...';
            socketReconnectTimer = setTimeout(() => {
                if (!running) {
                    return;
                }
                openSocket();
            }, delay);
        };

        const scheduleRoiSocketReconnect = () => {
            if (!running) {
                return;
            }
            roiSocketReconnectAttempts += 1;
            const delay = computeReconnectDelay(roiSocketReconnectAttempts);
            clearTimeoutSafe(roiSocketReconnectTimer);
            roiSocketReconnectTimer = setTimeout(() => {
                if (!running) {
                    return;
                }
                openRoiSocket();
            }, delay);
        };

        async function stopInference(options = {}) {
            const opts = options && typeof options === 'object' ? options : {};
            const forceStop = Boolean(opts.force);
            const silent = Boolean(opts.silent);
            if (!running && !forceStop) {
                startButton.disabled = false;
                stopButton.disabled = true;
                return;
            }
            const wasRunning = running;
            running = false;
            resetSocketReconnect();
            resetRoiSocketReconnect();
            try {
                if (wasRunning || forceStop) {
                    await fetchWithStatus(`/stop_inference/${cam}`, { method: 'POST' });
                }
            } catch (err) {
                if (!silent) {
                    console.error('Failed to stop inference stream', err);
                    showAlert('Failed to stop inference stream', 'error');
                }
            }
            if (socket) {
                socket.close();
                socket = null;
            }
            if (roiSocket) {
                roiSocket.close();
                roiSocket = null;
            }
            clearFrameWatchdog();
            stopLogUpdates();
            // clear last frame and related data to free memory
            clearCanvas();
            video.width = 0;
            video.height = 0;
            queueFrameForRender(null);
            rois = [];
            allRois = [];
            roiGrid.innerHTML = '';
            streamActive = false;
            statusEl.innerText = 'Stopped';
            startButton.innerText = 'Resume';
            startButton.disabled = false;
            stopButton.disabled = true;
            groupSelect.value = '';
            storeGroupSelection('');
            updateLogRoiOptions([]);
            if (!silent) {
                showAlert('Inference stopped', 'info');
            }
        }

        function openSocket() {
            const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
            const wsBase = `${wsScheme}://${location.host}`;
            clearTimeoutSafe(socketReconnectTimer);
            socketReconnectTimer = undefined;
            const ws = new WebSocket(`${wsBase}/ws/${cam}`);
            ws.binaryType = 'blob';
            ws.onopen = () => {
                if (!running) {
                    try { ws.close(); } catch (e) { /* noop */ }
                    return;
                }
                if (socket && socket !== ws) {
                    try { ws.close(); } catch (e) { /* noop */ }
                    return;
                }
                socketReconnectAttempts = 0;
                streamActive = false;
                statusEl.innerText = 'กำลังรับสตรีมภาพ...';
                scheduleFrameWatchdog(ws);
            };
            ws.onmessage = event => {
                if (!streamActive) {
                    streamActive = true;
                    if (statusEl) {
                        statusEl.innerText = 'Running';
                    }
                }
                scheduleFrameWatchdog(ws);
                queueFrameForRender(event.data);
            };
            ws.onerror = () => {
                if (socket === ws) {
                    try { ws.close(); } catch (e) { /* noop */ }
                }
            };
            ws.onclose = event => {
                if (socket === ws) {
                    socket = null;
                    clearFrameWatchdog();
                }
                if (!running) {
                    return;
                }
                streamActive = false;
                const normalClose = event && (event.code === 1000 || event.code === 1001);
                if (normalClose) {
                    statusEl.innerText = 'สตรีมหยุด';
                    return;
                }
                scheduleSocketReconnect();
            };
            socket = ws;
        }

        function openRoiSocket() {
            const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
            const wsBase = `${wsScheme}://${location.host}`;
            clearTimeoutSafe(roiSocketReconnectTimer);
            roiSocketReconnectTimer = undefined;
            const ws = new WebSocket(`${wsBase}/ws_roi_result/${cam}`);
            ws.onopen = () => {
                if (!running) {
                    try { ws.close(); } catch (e) { /* noop */ }
                    return;
                }
                if (roiSocket && roiSocket !== ws) {
                    try { ws.close(); } catch (e) { /* noop */ }
                    return;
                }
                roiSocketReconnectAttempts = 0;
            };
            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    if (Array.isArray(data.results)) {
                        const fallbackFrameTime =
                            typeof data.frame_time === 'number' ? data.frame_time : undefined;
                        setTimeout(() => {
                            data.results.forEach(item => applyRoiResult(item, fallbackFrameTime));
                        }, 0);
                    } else if (Object.prototype.hasOwnProperty.call(data, 'id')) {
                        setTimeout(() => {
                            applyRoiResult(data);
                        }, 0);
                    }
                } catch (e) {
                    console.error('ROI message error', e);
                }
            };
            ws.onerror = () => {
                if (roiSocket === ws) {
                    try { ws.close(); } catch (e) { /* noop */ }
                }
            };
            ws.onclose = event => {
                if (roiSocket === ws) {
                    roiSocket = null;
                }
                if (!running) {
                    return;
                }
                const normalClose = event && (event.code === 1000 || event.code === 1001);
                if (normalClose) {
                    return;
                }
                scheduleRoiSocketReconnect();
            };
            roiSocket = ws;
        }

        async function checkStatus() {
            let name = sourceSelect.value || '';
            const res = await fetchWithStatus(`/inference_status/${cam}`);
            const data = await res.json();
            const statusSource = typeof data.source === 'string' ? data.source : '';
            const statusGroup = typeof data.group === 'string' ? data.group : '';
            if (statusSource) {
                const options = Array.from(sourceSelect.options || []);
                const hasOption = options.some(opt => opt.value === statusSource);
                if (!hasOption) {
                    const opt = document.createElement('option');
                    opt.value = statusSource;
                    opt.textContent = statusSource;
                    sourceSelect.appendChild(opt);
                }
                if (sourceSelect.value !== statusSource) {
                    sourceSelect.value = statusSource;
                    storeValue('source', statusSource);
                    updateHeaderSourceLabel();
                }
            }
            if (!name && statusSource) {
                name = statusSource;
                storeValue('source', statusSource);
                updateHeaderSourceLabel();
            }
            if (data.running && name) {
                running = true;
                streamActive = false;
                openSocket();
                const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
                const cfg = await cfgRes.json();
                let roiPath = cfg.rois;
                if (!roiPath.startsWith('/')) {
                    roiPath = `data_sources/${cfg.name}/${roiPath}`;
                }
                const roiRes = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
                const roiData = await roiRes.json();
                allRois = roiData.rois || [];
                const roiList = allRois.filter(r => (r.type ?? 'roi') === 'roi');
                const normalizedStatusGroup = typeof statusGroup === 'string' ? statusGroup : '';
                const activeGroup = loadGroupOptions(roiList, normalizedStatusGroup);
                const groupToUse = (normalizedStatusGroup || activeGroup || '').trim();
                lastActiveGroup = groupToUse || '';
                if (groupToUse === 'all') {
                    rois = roiList;
                } else if (groupToUse) {
                    rois = roiList.filter(r => (r.group ?? r.page ?? r.name) === groupToUse);
                } else {
                    rois = [];
                }
                roiGrid.innerHTML = '';
                rois.forEach(r => {
                    if (r && r.id !== undefined && r.id !== null) {
                        ensureRoiItem(r.id, r);
                        updateRoiModuleLabel(r.id);
                    }
                });
                if (roiSocket) {
                    roiSocket.close();
                    roiSocket = null;
                }
                openRoiSocket();
                stopLogUpdates();
                const logSourceName = cfg.name || statusSource || name;
                startLogUpdates(logSourceName);
                setRunningUI('กำลังรับสตรีมภาพ...');
            } else {
                statusEl.innerText = 'Idle';
                startButton.innerText = 'Start';
                startButton.disabled = false;
                stopButton.disabled = true;
                running = false;
                stopLogUpdates();
            }
        }

        async function switchGroup() {
            const selected = groupSelect.value;
            storeGroupSelection(selected);
            if (!selected) {
                updateLogRoiOptions([]);
                return;
            }

            const roiList = allRois.filter(r => (r.type ?? 'roi') === 'roi');
            const filtered = selected === 'all'
                ? roiList
                : roiList.filter(r => (r.group ?? r.page ?? r.name) === selected);

            updateLogRoiOptions(filtered);

            if (running) {
                await stopInference();
            }

            const hasCachedRois = allRois.length > 0;
            await startInference(hasCachedRois ? filtered : null, selected);
        }

        function setRunningUI(message) {
            if (typeof message === 'string' && message.length > 0) {
                statusEl.innerText = message;
            } else if (streamActive) {
                statusEl.innerText = 'Running';
            } else {
                statusEl.innerText = 'กำลังรับสตรีมภาพ...';
            }
            startButton.disabled = true;
            stopButton.disabled = false;
            startButton.innerText = 'Start';
        }

        (async () => {
            await loadSources();
            await checkStatus();
        })();

        return {
            stopInference,
            camId: cam,
            clearStoredValues() {
                ['source', 'interval', 'group'].forEach(key => {
                    localStorage.removeItem(makeStorageKey(key));
                });
            },
        };
    }

  const inferenceRows = document.getElementById('inferenceRows');
  const addButton = document.getElementById('addInferenceBtn');
  const controllers = new Map();
  const camIdToCell = new Map();
  let nextCamIndex = 1;

  function sanitizeCellId(rawId) {
      const cleaned = (rawId || '').replace(/[^a-zA-Z0-9_-]/g, '_');
      return cleaned || `cam${nextCamIndex}`;
  }

  function ensureUniqueCellId(baseId) {
      let candidate = baseId;
      let counter = 1;
      while (controllers.has(candidate) || document.getElementById(candidate)) {
          candidate = `${baseId}_${counter++}`;
      }
      return candidate;
  }

  function updateNextIndexFromCellId(cellId) {
      const match = String(cellId || '').match(/(\d+)$/);
      if (match) {
          const value = parseInt(match[1], 10);
          if (!Number.isNaN(value) && value >= nextCamIndex) {
              nextCamIndex = value + 1;
          }
      }
  }

  function generateCellId() {
      let candidate;
      do {
          candidate = `cam${nextCamIndex++}`;
      } while (controllers.has(candidate) || document.getElementById(candidate));
      return candidate;
  }

  function createRowElement(cellId, titleText, camId) {
      const row = document.createElement('div');
      row.className = 'cam-row';
      if (inferenceRows.children.length > 0) {
          row.classList.add('mt-2');
      }
      row.dataset.cellId = cellId;
      row.innerHTML = `
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
          <div>
            <h5 class="mb-0" id="${cellId}-title">${titleText}</h5>
            <div class="text-muted small" id="${cellId}-label">ID: ${camId}</div>
          </div>
          <div class="d-flex gap-2 flex-wrap">
            <button type="button" class="btn btn-outline-danger btn-sm" data-action="remove" data-cell-id="${cellId}">ลบงานนี้</button>
          </div>
        </div>
        <div class="video-col">
          <div class="card roi-card video-card">
            <div id="${cellId}" class="cam-cell">
              <div class="d-flex align-items-center mb-2 gap-2 menu-select-list flex-wrap">
                <label for="${cellId}-sourceSelect" class="form-label mb-0">Source:</label>
                <select id="${cellId}-sourceSelect" class="form-select w-auto"></select>
                <label for="${cellId}-intervalInput" class="form-label mb-0">Time (interval):</label>
                <input id="${cellId}-intervalInput" type="number" class="form-control w-auto" min="0" step="0.1" value="1" />
                <label for="${cellId}-groupSelect" class="form-label mb-0">Group:</label>
                <select id="${cellId}-groupSelect" class="form-select w-auto flex-grow-1" style="min-width:0;"></select>
              </div>
              <div class="d-flex align-items-center gap-2 flex-wrap mb-2">
                <button id="${cellId}-startButton" class="btn btn-primary">Start</button>
                <button id="${cellId}-stopButton" class="btn btn-danger" disabled>Stop</button>
                <div class="ms-auto text-muted small" id="${cellId}-status"></div>
              </div>
              <div class="video-wrapper">
                <canvas id="${cellId}-video" class="stream-video"></canvas>
              </div>
            </div>
          </div>
          <div class="card roi-card log-card">
            <div class="d-flex align-items-center mb-2 gap-2 menu-select-list">
              <label for="${cellId}-logRoiSelect" class="form-label mb-0">ROI:</label>
              <select id="${cellId}-logRoiSelect" class="form-select w-auto"></select>
            </div>
            <div class="log-wrapper">
              <table id="${cellId}-logTable" class="table table-striped">
                <thead><tr><th>Log</th></tr></thead>
                <tbody id="${cellId}-logBody"></tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="card roi-card roi-list-card">
          <div id="${cellId}-rois" class="roi-grid"></div>
        </div>`;
      inferenceRows.appendChild(row);
      return row;
  }

  function addInferenceRow({ cellId, camId, title, defaultSource, defaultInterval, defaultGroup } = {}) {
      let desiredCellId = cellId ? sanitizeCellId(cellId) : '';
      if (desiredCellId) {
          desiredCellId = ensureUniqueCellId(desiredCellId);
          updateNextIndexFromCellId(desiredCellId);
      }
      const actualCellId = desiredCellId || generateCellId();
      const actualCamId = typeof camId === 'string' && camId.length > 0
          ? camId
          : `inf_${actualCellId}`;
      const displayTitle = title || `งาน Inference ${controllers.size + 1}`;
      createRowElement(actualCellId, displayTitle, actualCamId);
      initRoiLayout(actualCellId);
      const controller = createCameraController(actualCellId, {
          camId: actualCamId,
          title: displayTitle,
          defaultSource,
          defaultInterval,
          defaultGroup,
      });
      controllers.set(actualCellId, controller);
      camIdToCell.set(actualCamId, actualCellId);
      return actualCellId;
  }

  async function removeInferenceRow(cellId) {
      const controller = controllers.get(cellId);
      if (controller && typeof controller.stopInference === 'function') {
          try {
              await controller.stopInference({ force: true, silent: true });
          } catch (err) {
              console.warn('Failed to stop inference before removal', err);
          }
      }
      controllers.delete(cellId);
      if (controller && controller.camId) {
          camIdToCell.delete(controller.camId);
      }
      if (controller && typeof controller.clearStoredValues === 'function') {
          controller.clearStoredValues();
      }
      const row = inferenceRows.querySelector(`.cam-row[data-cell-id="${cellId}"]`);
      if (row) {
          row.remove();
      }
      showAlert('ลบงาน Inference แล้ว', 'info');
      if (controllers.size === 0) {
          addInferenceRow();
      }
  }

  addButton.addEventListener('click', () => {
      const cellId = addInferenceRow();
      showAlert('สร้างงาน Inference ใหม่แล้ว', 'success');
      const sourceSelect = document.getElementById(`${cellId}-sourceSelect`);
      if (sourceSelect) {
          sourceSelect.focus();
      }
  });

  inferenceRows.addEventListener('click', async event => {
      const button = event.target.closest('[data-action="remove"]');
      if (!button) {
          return;
      }
      const cellId = button.getAttribute('data-cell-id');
      if (!cellId) {
          return;
      }
      const confirmed = window.confirm('ต้องการลบงาน Inference นี้หรือไม่? ระบบจะหยุดการประมวลผลให้ทันที');
      if (!confirmed) {
          return;
      }
      await removeInferenceRow(cellId);
  });

  async function bootstrapExisting() {
      let createdAny = false;
      try {
          const res = await fetch('/api/dashboard');
          if (res.ok) {
              const payload = await res.json();
              const cameras = Array.isArray(payload?.cameras) ? payload.cameras : [];
              cameras
                  .filter(cam => (
                      typeof cam?.cam_id === 'string'
                      && cam.cam_id.startsWith('inf_')
                      && cam.inference_running
                  ))
                  .forEach(cam => {
                      const camId = cam.cam_id;
                      if (camIdToCell.has(camId)) {
                          return;
                      }
                      const rawCell = camId.replace(/^inf_/, '') || camId;
                      const cellId = addInferenceRow({
                          cellId: rawCell,
                          camId,
                          title: cam.name || camId,
                          defaultSource: cam.name || '',
                          defaultInterval: cam.interval,
                          defaultGroup: cam.group,
                      });
                      createdAny = true;
                  });
          }
      } catch (err) {
          console.warn('ไม่สามารถโหลดงาน Inference ที่มีอยู่ได้', err);
      }
      if (!createdAny && controllers.size === 0) {
          addInferenceRow();
      }
  }

  bootstrapExisting();
  })();
  </script>
