<div class="d-flex flex-column gap-3">
  <div class="d-flex align-items-start justify-content-between flex-wrap gap-3">
    <div>
      <h4 class="mb-1">จัดการงาน Inference สำหรับหน้าเอกสาร</h4>
      <p class="mb-0 text-muted">สร้างหลายงานได้พร้อมกันเพื่อทดสอบการตรวจจับหน้าและ ROI ได้อย่างยืดหยุ่น</p>
    </div>
    <div class="d-flex gap-2 flex-wrap">
      <button type="button" id="addPageInferenceBtn" class="btn btn-success">เพิ่มงาน Inference</button>
    </div>
  </div>
  
  <div id="pageInferenceRows" class="d-flex flex-column gap-4"></div>
</div>
<script>
  (function() {
    function initRoiLayout(cellId) {
      const videoCell = document.getElementById(cellId);
      const videoCol = videoCell ? videoCell.closest('.video-col') : null;
      const roiContainer = document.getElementById(`${cellId}-rois`);
      const roiCard = roiContainer ? roiContainer.closest('.roi-list-card') : null;
      if (!videoCol || !roiCard) {
        return;
      }

      const roiGrid = roiCard.querySelector('.roi-grid');
      if (roiGrid) {
        roiGrid.style.height = '100%';
      }

      const updateHeight = () => {
        const rect = videoCol.getBoundingClientRect();
        if (rect && rect.height) {
          roiCard.style.maxHeight = `${rect.height}px`;
        }
      };

      updateHeight();

      if ('ResizeObserver' in window) {
        const observer = new ResizeObserver(() => updateHeight());
        observer.observe(videoCol);
      }

      window.addEventListener('resize', updateHeight);
    }

    function createCameraController(cellId, options = {}) {
      let socket;
      let roiSocket;
      let socketReconnectTimer;
      let roiSocketReconnectTimer;
      let socketReconnectAttempts = 0;
      let roiSocketReconnectAttempts = 0;
      const INITIAL_RECONNECT_DELAY = 500;
      const MAX_RECONNECT_DELAY = 10000;
      const computeReconnectDelay = attempt => {
        const step = Math.max(1, attempt);
        const delay = INITIAL_RECONNECT_DELAY * Math.pow(2, step - 1);
        return Math.min(MAX_RECONNECT_DELAY, delay);
      };
      let rois = [];
      let allRois = [];
      let running = false;
      let streamActive = false;
      let currentStreamHealth = null;
      const FRAME_TIMEOUT_MS = 5000;
      let frameWatchdogTimer;
      const {
        camId: camIdOverride,
        title: providedTitle,
        defaultSource: providedSource,
        defaultInterval,
      } = options || {};
      const cam = typeof camIdOverride === 'string' && camIdOverride.length > 0
        ? camIdOverride
        : `page_${cellId}`;
      const storageNamespace = `inference-page:${cam}`;
      const makeStorageKey = suffix => `${storageNamespace}:${suffix}`;
      const readStoredValue = suffix => localStorage.getItem(makeStorageKey(suffix));
      const storeValue = (suffix, value) => {
        if (value === undefined || value === null || value === '') {
          localStorage.removeItem(makeStorageKey(suffix));
        } else {
          localStorage.setItem(makeStorageKey(suffix), value);
        }
      };
      const migrateLegacyKey = legacySuffix => {
        const legacyKey = `${cellId}-${legacySuffix}`;
        const legacyValue = localStorage.getItem(legacyKey);
        if (legacyValue !== null && readStoredValue(legacySuffix) === null) {
          storeValue(legacySuffix, legacyValue);
        }
        if (legacyValue !== null) {
          localStorage.removeItem(legacyKey);
        }
      };
      ['source', 'interval'].forEach(migrateLegacyKey);
      const getEl = suffix => document.getElementById(`${cellId}-${suffix}`);
        const video = getEl('video');
        const videoWrapper = video ? video.closest('.video-wrapper') : null;
        const supportsImageBitmap = typeof window !== 'undefined'
          && typeof createImageBitmap === 'function';
        const bitmapRendererCtx = supportsImageBitmap && video && typeof video.getContext === 'function'
          ? video.getContext('bitmaprenderer')
          : null;
        const canUseBitmapRenderer = Boolean(
          bitmapRendererCtx && typeof bitmapRendererCtx.transferFromImageBitmap === 'function'
        );
        const videoCtx = canUseBitmapRenderer
          ? bitmapRendererCtx
          : (video && typeof video.getContext === 'function'
            ? video.getContext('2d')
            : null);
        let allowBitmapDecoding = supportsImageBitmap;
        let fallbackImgEl;
        let fallbackObjectUrl;
      const startButton = getEl('startButton');
      const stopButton = getEl('stopButton');
      const statusEl = getEl('status');
      const titleEl = getEl('title');
      const labelEl = getEl('label');
      const sourceSelect = getEl('sourceSelect');
      const roiGrid = getEl('rois');
      const logBody = getEl('logBody');
      const logRoiSelect = getEl('logRoiSelect');
      const intervalInput = getEl('intervalInput');
      const pageNameEl = getEl('pageName');
      const scoreTableBody = getEl('pageScoresBody');
      const scoreTableWrapper = getEl('pageScoresWrapper');
      const scoreEmptyEl = getEl('pageScoresEmpty');
      let logTimer;
      const clearTimeoutSafe = timer => {
        if (typeof timer === 'number') {
          clearTimeout(timer);
        }
      };
      const clearFrameWatchdog = () => {
        clearTimeoutSafe(frameWatchdogTimer);
        frameWatchdogTimer = undefined;
      };

      const setStreamHealth = health => {
        if (health && typeof health === 'object') {
          currentStreamHealth = { ...health };
        } else {
          currentStreamHealth = null;
        }
      };

      const deriveStreamMessage = defaultText => {
        if (!running) {
          return defaultText || '';
        }
        const state = currentStreamHealth && typeof currentStreamHealth.state === 'string'
          ? currentStreamHealth.state
          : '';
        if (state === 'outage') {
          return 'สตรีมภาพขาดหาย กำลังเชื่อมใหม่...';
        }
        if (state === 'starting') {
          return 'กำลังเตรียมสตรีม...';
        }
        if (state === 'active') {
          if (defaultText && defaultText.length > 0) {
            return defaultText;
          }
          return streamActive ? 'Running' : 'กำลังรับสตรีมภาพ...';
        }
        if (state === 'stopped') {
          return 'Stopped';
        }
        return defaultText && defaultText.length > 0
          ? defaultText
          : (streamActive ? 'Running' : 'กำลังรับสตรีมภาพ...');
      };
      const scheduleFrameWatchdog = wsInstance => {
        if (FRAME_TIMEOUT_MS <= 0 || !running || socket !== wsInstance) {
          return;
        }
        clearFrameWatchdog();
        frameWatchdogTimer = setTimeout(() => {
          frameWatchdogTimer = undefined;
          if (!running || socket !== wsInstance) {
            return;
          }
          streamActive = false;
          setStreamHealth({ state: 'outage' });
          if (statusEl) {
            statusEl.innerText = deriveStreamMessage('ไม่พบภาพจากกล้อง กำลังเชื่อมต่อใหม่...');
          }
          try {
            wsInstance.close(4000, 'frame_timeout');
          } catch (err) {
            console.warn('Stream watchdog close failed', err);
          }
        }, FRAME_TIMEOUT_MS);
      };
        const revokeFallbackUrl = () => {
          if (fallbackObjectUrl) {
            URL.revokeObjectURL(fallbackObjectUrl);
            fallbackObjectUrl = null;
          }
        };

        const hideFallbackImage = () => {
          if (fallbackImgEl) {
            fallbackImgEl.style.display = 'none';
            fallbackImgEl.removeAttribute('src');
          }
          if (video) {
            video.style.display = '';
          }
          revokeFallbackUrl();
        };

        const clearCanvas = () => {
          hideFallbackImage();
          if (!video) {
            return;
          }
          if (canUseBitmapRenderer) {
            video.width = 0;
            video.height = 0;
          } else if (videoCtx && typeof videoCtx.clearRect === 'function') {
            videoCtx.clearRect(0, 0, video.width || 0, video.height || 0);
          }
        };
      const FRAME_BLOB_MIME = 'image/jpeg';
      const toFrameBlob = data => {
        if (!data) {
          return null;
        }
        if (data instanceof Blob) {
          return data;
        }
        if (data instanceof ArrayBuffer) {
          return new Blob([data], { type: FRAME_BLOB_MIME });
        }
        if (ArrayBuffer.isView && ArrayBuffer.isView(data)) {
          const { buffer, byteOffset = 0, byteLength = 0 } = data;
          if (buffer instanceof ArrayBuffer) {
            if (typeof buffer.slice === 'function') {
              const sliced = buffer.slice(byteOffset, byteOffset + byteLength);
              return new Blob([sliced], { type: FRAME_BLOB_MIME });
            }
            if (typeof data.subarray === 'function') {
              const clonedView = data.subarray(0, data.length ?? undefined);
              if (clonedView) {
                return new Blob([clonedView], { type: FRAME_BLOB_MIME });
              }
            }
            return new Blob([buffer], { type: FRAME_BLOB_MIME });
          }
        }
        return null;
      };

      const queueFrameForRender = (() => {
        if (!videoCtx) {
          return () => {};
        }
        let pendingFrame = null;
        let isRendering = false;

        const getDisplaySize = (width, height) => {
          if (!video) {
            return { width, height };
          }

          const wrapperRect = videoWrapper && typeof videoWrapper.getBoundingClientRect === 'function'
            ? videoWrapper.getBoundingClientRect()
            : null;
          const containerWidth = wrapperRect && wrapperRect.width ? wrapperRect.width : (video.parentElement?.clientWidth || 0);
          const widthLimit = containerWidth > 0 ? containerWidth : Math.min(width, 1280);
          const viewportLimit = typeof window !== 'undefined' && window.innerHeight
            ? Math.max(320, window.innerHeight * 0.6)
            : height;
          const heightLimit = Math.min(height, viewportLimit);
          const scale = Math.min(1,
            widthLimit > 0 ? widthLimit / width : 1,
            heightLimit > 0 ? heightLimit / height : 1,
          );
          const targetWidth = Math.max(1, Math.round(width * scale));
          const targetHeight = Math.max(1, Math.round(height * scale));
          return { width: targetWidth, height: targetHeight };
        };

        const applyDisplaySize = (targetWidth, targetHeight) => {
          if (!video) {
            return;
          }
          if (video.width !== targetWidth) {
            video.width = targetWidth;
          }
          if (video.height !== targetHeight) {
            video.height = targetHeight;
          }
          if (video.style.width !== `${targetWidth}px`) {
            video.style.width = `${targetWidth}px`;
          }
          if (video.style.height !== `${targetHeight}px`) {
            video.style.height = `${targetHeight}px`;
          }
        };

          const ensureFallbackImage = () => {
            if (fallbackImgEl) {
              return fallbackImgEl;
            }
            if (!videoWrapper) {
              return null;
            }
            const img = document.createElement('img');
            img.id = `${cellId}-video-fallback`;
            img.className = video ? video.className : 'stream-video';
            img.alt = 'Stream preview';
            img.style.display = 'none';
            videoWrapper.appendChild(img);
            fallbackImgEl = img;
            return fallbackImgEl;
          };

          const renderWithFallbackImage = async blob => {
            const imgEl = ensureFallbackImage();
            if (!imgEl) {
              return;
            }
            if (video) {
              video.style.display = 'none';
            }
            imgEl.style.display = '';
            revokeFallbackUrl();
            await new Promise((resolve, reject) => {
              const objectUrl = URL.createObjectURL(blob);
              fallbackObjectUrl = objectUrl;
              imgEl.onload = () => {
                URL.revokeObjectURL(objectUrl);
                fallbackObjectUrl = null;
                resolve();
              };
              imgEl.onerror = err => {
                URL.revokeObjectURL(objectUrl);
                fallbackObjectUrl = null;
                reject(err);
              };
              imgEl.src = objectUrl;
            });
          };

          const processNext = async () => {
            if (!pendingFrame) {
              isRendering = false;
              return;
            }
            isRendering = true;
            const blob = pendingFrame;
            pendingFrame = null;
            let bitmap;
            try {
              if (allowBitmapDecoding && typeof createImageBitmap === 'function') {
                hideFallbackImage();
                bitmap = await createImageBitmap(blob);
                if (!bitmap) {
                  throw new Error('empty_bitmap');
                }
                const width = bitmap.width || 0;
                const height = bitmap.height || 0;
                const { width: targetWidth, height: targetHeight } = getDisplaySize(width, height);
                applyDisplaySize(targetWidth, targetHeight);
                if (canUseBitmapRenderer && typeof videoCtx.transferFromImageBitmap === 'function') {
                  videoCtx.transferFromImageBitmap(bitmap);
                } else if (
                  videoCtx
                  && typeof videoCtx.clearRect === 'function'
                  && typeof videoCtx.drawImage === 'function'
                ) {
                  videoCtx.clearRect(0, 0, targetWidth, targetHeight);
                  videoCtx.drawImage(bitmap, 0, 0, targetWidth, targetHeight);
                }
              } else {
                await renderWithFallbackImage(blob);
              }
            } catch (err) {
              console.error('Failed to render frame', err);
              if (allowBitmapDecoding) {
                allowBitmapDecoding = false;
                try {
                  await renderWithFallbackImage(blob);
                } catch (fallbackErr) {
                  console.error('Fallback render failed', fallbackErr);
                }
              }
            } finally {
              if (bitmap && typeof bitmap.close === 'function') {
                bitmap.close();
              }
            if (pendingFrame) {
              processNext();
            } else {
              isRendering = false;
            }
          }
        };

          return input => {
            const blob = toFrameBlob(input);
            if (!blob) {
              pendingFrame = null;
              hideFallbackImage();
              return;
            }
            pendingFrame = blob;
            if (!isRendering) {
              processNext();
            }
          };
      })();
      let isLogUpdating = false;
      let logSessionId = 0;
      let currentLogSource;
      let roiGroupIndex = new Map();
      let activeGroupName = '';
      const baseTitle = typeof providedTitle === 'string' && providedTitle.length > 0
        ? providedTitle
        : 'งาน Inference';
      if (titleEl) {
        titleEl.textContent = baseTitle;
      }
      const baseLabelText = `ID: ${cam}`;
      if (labelEl) {
        labelEl.textContent = baseLabelText;
      }
      const storedInterval = readStoredValue('interval');
      if (storedInterval) {
        intervalInput.value = storedInterval;
      } else if (defaultInterval !== undefined && defaultInterval !== null) {
        intervalInput.value = String(defaultInterval);
      } else {
        intervalInput.value = '1';
      }

      const formatTs = ts => {
        if (!ts) return '';
        const d = new Date(ts * 1000);
        const ms = String(d.getMilliseconds()).padStart(3, '0');
        return `${d.toLocaleTimeString('th-TH', { hour12: false })}.${ms}`;
      };

      const formatDuration = seconds => {
        if (!Number.isFinite(seconds) || seconds < 0) return '';
        if (seconds >= 1) {
          return `${seconds.toFixed(2)} s`;
        }
        if (seconds >= 0.001) {
          return `${Math.round(seconds * 1000)} ms`;
        }
        return `${(seconds * 1000).toFixed(2)} ms`;
      };

      const normalizeGroupName = value => (typeof value === 'string' ? value.trim() : '');
      const getRoiGroupName = roi => normalizeGroupName(roi?.group ?? roi?.page ?? '');
      const ensureArray = value => (Array.isArray(value) ? value : []);

      function rebuildRoiGroupIndex(list) {
        roiGroupIndex = new Map();
        ensureArray(list).forEach(entry => {
          if (!isRoiType(entry)) {
            return;
          }
          const groupName = getRoiGroupName(entry);
          if (!groupName) {
            return;
          }
          if (!roiGroupIndex.has(groupName)) {
            roiGroupIndex.set(groupName, []);
          }
          roiGroupIndex.get(groupName).push(entry);
        });
      }

      function setActiveGroup(groupName) {
        const normalized = normalizeGroupName(groupName);
        if (normalized === activeGroupName) {
          return;
        }
        activeGroupName = normalized;
        roiGrid.innerHTML = '';
        rois = [];
        if (!normalized) {
          updateLogRoiOptions([]);
          return;
        }
        const list = roiGroupIndex.get(normalized) || [];
        rois = list;
        list.forEach(r => {
          if (r && r.id !== undefined && r.id !== null) {
            ensureRoiItem(r.id, r);
            updateRoiModuleLabel(r.id);
          }
        });
        updateLogRoiOptions(list);
      }

      const renderScoreboard = (scores = []) => {
        if (!scoreTableBody) {
          return;
        }
        scoreTableBody.innerHTML = '';
        const list = Array.isArray(scores) ? scores : [];
        list.forEach(item => {
          const tr = document.createElement('tr');
          const tdPage = document.createElement('td');
          tdPage.textContent = item?.page ?? '';
          const tdScore = document.createElement('td');
          const scoreValue = typeof item?.score === 'number' ? item.score : null;
          tdScore.textContent = scoreValue !== null ? scoreValue.toFixed(2) : '';
          tr.appendChild(tdPage);
          tr.appendChild(tdScore);
          scoreTableBody.appendChild(tr);
        });
        const hasScores = list.length > 0;
        if (scoreTableWrapper) {
          scoreTableWrapper.classList.toggle('d-none', !hasScores);
        }
        if (scoreEmptyEl) {
          scoreEmptyEl.classList.toggle('d-none', hasScores);
        }
      };

      const resetScoreboard = () => {
        if (pageNameEl) {
          pageNameEl.textContent = '-';
        }
        renderScoreboard([]);
        setActiveGroup('');
      };
      resetScoreboard();

      const updateHeaderSourceLabel = () => {
        if (!labelEl) {
          return;
        }
        const sourceName = sourceSelect.value || '';
        labelEl.textContent = sourceName
          ? `${baseLabelText} • Source: ${sourceName}`
          : baseLabelText;
      };

      sourceSelect.onchange = () => {
        storeValue('source', sourceSelect.value);
        updateHeaderSourceLabel();
      };

      startButton.onclick = () => { startInference(); };
      stopButton.onclick = () => { stopInference(); };
      logRoiSelect.onchange = () => {
        if (currentLogSource) {
          startLogUpdates(currentLogSource);
        }
      };

      async function fetchWithStatus(url, options = {}) {
        statusEl.innerText = 'กำลังโหลด...';
        try {
          const res = await fetch(url, options);
          if (!res.ok) throw new Error('network');
          statusEl.innerText = 'สำเร็จ';
          return res;
        } catch (err) {
          statusEl.innerText = 'เกิดข้อผิดพลาด';
          throw err;
        }
      }

      async function loadSources() {
        try {
          const res = await fetchWithStatus('/source_list');
          if (!res.ok) throw new Error('Bad response');
          const data = await res.json();
          sourceSelect.innerHTML = '';
          if (data.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'No sources available';
            sourceSelect.appendChild(opt);
            statusEl.innerText = 'Create a source first';
            showAlert('No sources available', 'error');
          } else {
            data.forEach(item => {
              const opt = document.createElement('option');
              opt.value = item.name;
              opt.textContent = item.name;
              sourceSelect.appendChild(opt);
            });
            const stored = readStoredValue('source') || '';
            const preferredSource = stored
              || (typeof providedSource === 'string' ? providedSource : '');
            const availableSources = new Set(data.map(item => item.name));
            if (preferredSource && availableSources.has(preferredSource)) {
              sourceSelect.value = preferredSource;
              storeValue('source', preferredSource);
            }
            updateHeaderSourceLabel();
            showAlert('Sources loaded', 'success');
          }
        } catch (err) {
          console.error('Failed to load sources', err);
          sourceSelect.innerHTML = '';
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'Error loading sources';
          sourceSelect.appendChild(opt);
          statusEl.innerText = 'Error fetching sources';
          showAlert('Failed to load sources', 'error');
          updateHeaderSourceLabel();
        }
      }

      const getModuleElementId = id => `${cellId}-module-${id}`;

      function findRoiDataById(id) {
        const key = String(id);
        const match = rois.find(r => String(r?.id) === key);
        if (match) return match;
        return allRois.find(r => String(r?.id) === key) || null;
      }

      function normalizeModule(value) {
        return typeof value === 'string' ? value.trim() : '';
      }

      function updateRoiModuleLabel(id, override = '') {
        const moduleEl = document.getElementById(getModuleElementId(id));
        if (!moduleEl) return;
        const overrideText = normalizeModule(override);
        const fallback = normalizeModule(findRoiDataById(id)?.module ?? '');
        const moduleName = overrideText || fallback;
        moduleEl.textContent = moduleName ? `โมดูล: ${moduleName}` : 'โมดูล: -';
      }

      function isRoiType(data) {
        return (data?.type ?? 'roi') === 'roi';
      }

      function ensureRoiItem(id, roiData = null) {
        if (!activeGroupName) {
          return;
        }
        if (document.getElementById(`${cellId}-roi-${id}`)) return;
        const key = String(id);
        const r =
          roiData
          || rois.find(entry => String(entry?.id) === key)
          || findRoiDataById(id)
          || null;
        if (!r || !isRoiType(r)) {
          return;
        }
        if (getRoiGroupName(r) !== activeGroupName) {
          return;
        }
        const item = document.createElement('div');
        item.className = 'roi-item';
        const title = document.createElement('h4');
        title.className = 'roi-title';
        title.textContent = r.name || `ROI ${id}`;
        const img = document.createElement('img');
        img.id = `${cellId}-roi-${id}`;
        img.className = 'roi-image';
        const moduleLine = document.createElement('p');
        moduleLine.id = getModuleElementId(id);
        moduleLine.className = 'roi-module';
        const t = document.createElement('p');
        t.id = `${cellId}-time-${id}`;
        t.className = 'roi-time';
        const p = document.createElement('p');
        p.id = `${cellId}-text-${id}`;
        p.className = 'roi-text';
        item.appendChild(title);
        item.appendChild(img);
        item.appendChild(moduleLine);
        item.appendChild(t);
        item.appendChild(p);
        roiGrid.appendChild(item);
        updateRoiModuleLabel(id);
      }

      function applyRoiResult(result, fallbackFrameTime) {
        if (!result) return;
        const roiId = result.id;
        if (roiId === undefined || roiId === null) return;
        const roiData = findRoiDataById(roiId);
        if (!roiData || !isRoiType(roiData)) {
          return;
        }
        if (getRoiGroupName(roiData) !== activeGroupName) {
          return;
        }
        ensureRoiItem(roiId, roiData);
        updateRoiModuleLabel(roiId, result.module);
        const imgEl = document.getElementById(`${cellId}-roi-${roiId}`);
        if (imgEl && Object.prototype.hasOwnProperty.call(result, 'image')) {
          imgEl.src = result.image ? `data:image/jpeg;base64,${result.image}` : '';
        }
        const textEl = document.getElementById(`${cellId}-text-${roiId}`);
        if (textEl) {
          const text = result.text ?? '';
          textEl.textContent = text ? `ข้อความ: ${text}` : 'ข้อความ: -';
        }
        const timeEl = document.getElementById(`${cellId}-time-${roiId}`);
        if (timeEl) {
          const duration = typeof result.duration === 'number'
            ? result.duration
            : Number.NaN;
          const durationText = formatDuration(duration);
          if (durationText) {
            timeEl.textContent = `เวลา: ${durationText}`;
          } else {
            const ts = typeof result.frame_time === 'number'
              ? result.frame_time
              : fallbackFrameTime;
            timeEl.textContent = ts ? `เวลา: ${formatTs(ts)}` : '';
          }
        }
      }

      function startLogUpdates(sourceName){
        currentLogSource = sourceName;
        stopLogUpdates();
        const sessionId = logSessionId;
        isLogUpdating = true;
        async function fetchLog(){
          if(!isLogUpdating || sessionId !== logSessionId){
            return;
          }
          try{
            const res=await fetch(`/read_log?source=${encodeURIComponent(sourceName)}&lines=40&_=${Date.now()}`);
            const data=await res.json();
            if(sessionId !== logSessionId){
              return;
            }
            const selectedRoi=logRoiSelect.value;
            logBody.innerHTML='';
            const lines=(data.lines||[]).slice().reverse();
            lines.forEach(line=>{
              const marker='AGGREGATED_ROI ';
              const idx=line.indexOf(marker);
              if(idx!==-1){
                const prefix=line.slice(0,idx).trim();
                const payload=line.slice(idx+marker.length).trim();
                try{
                  const parsed=JSON.parse(payload);
                  const results=Array.isArray(parsed.results)?parsed.results:[];
                  const frameTs=typeof parsed.frame_time==='number'?parsed.frame_time:null;
                  const resultTs=typeof parsed.result_time==='number'?parsed.result_time:null;
                  const groupLabel=parsed.group||'';
                  results.forEach(res=>{
                    const roiId=res?.id??res?.roi_id??res?.ROI_ID;
                    if(roiId===undefined||roiId===null)return;
                    if(selectedRoi!=='all'&&String(roiId)!==selectedRoi)return;
                    const tr=document.createElement('tr');
                    const td=document.createElement('td');
                    const parts=[];
                    if(prefix)parts.push(prefix);
                    if(frameTs)parts.push(`frame=${formatTs(frameTs)}`);
                    if(resultTs)parts.push(`result=${formatTs(resultTs)}`);
                    parts.push(`roi_id=${roiId}`);
                    if(res.name)parts.push(`name=${res.name}`);
                    const moduleName=typeof res.module==='string'?res.module.trim():'';
                    if(moduleName)parts.push(`module=${moduleName}`);
                    if(groupLabel)parts.push(`group=${groupLabel}`);
                    if(typeof res.duration==='number'){
                      const dur=formatDuration(res.duration);
                      if(dur)parts.push(`duration=${dur}`);
                    }
                    const textValue=typeof res.text==='string'?res.text:'';
                    parts.push(`text=${textValue}`);
                    td.textContent=parts.join(' | ');
                    tr.appendChild(td);
                    logBody.appendChild(tr);
                  });
                  return;
                }catch(e){}
              }
              if(selectedRoi==='all'||line.includes(`roi_id=${selectedRoi}`)){
                const tr=document.createElement('tr');
                const td=document.createElement('td');
                td.textContent=line;
                tr.appendChild(td);
                logBody.appendChild(tr);
              }
            });
          }catch(e){}
          finally{
            if(isLogUpdating && sessionId === logSessionId){
              logTimer=setTimeout(fetchLog,1000);
            }
          }
        }
        fetchLog();
      }

      function stopLogUpdates(){
        isLogUpdating=false;
        logSessionId++;
        if(logTimer){
          clearTimeout(logTimer);
          logTimer=null;
        }
        logBody.innerHTML='';
      }

      function updateLogRoiOptions(list){
        logRoiSelect.innerHTML='';
        const optAll=document.createElement('option');
        optAll.value='all';
        optAll.textContent='All';
        logRoiSelect.appendChild(optAll);
        list.forEach(r=>{
          const opt=document.createElement('option');
          opt.value=r.id;
          opt.textContent=r.id;
          logRoiSelect.appendChild(opt);
        });
      }

      async function startInference(roisOverride = null) {
        if (running) return;
        running = true;
        startButton.disabled = true;
        const name = sourceSelect.value;
        if (!name) {
          statusEl.innerText = 'Select source first';
          running = false;
          startButton.disabled = false;
          showAlert('Select source first', 'error');
          return;
        }
        storeValue('source', name);

        const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
        const cfg = await cfgRes.json();

        const { module: _unused, rois: roiPathRaw, ...camCfg } = cfg;
        const interval = parseFloat(intervalInput.value) || 1;
        storeValue('interval', interval);
        let roiPath = roiPathRaw;
        if (!roiPath.startsWith('/')) {
          roiPath = `data_sources/${cfg.name}/${roiPath}`;
        }
        const res = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
        const data = await res.json();
        statusEl.innerText = '';
        const roiEntries = Array.isArray(data.rois) ? data.rois : [];
        allRois = roiEntries;
        rebuildRoiGroupIndex(roiEntries);
        resetScoreboard();
        const payloadRois = roiEntries;
        const hasAnyRoiEntry = roiEntries.length > 0;

        let startData;
        let startRes;
        statusEl.innerText = 'กำลังโหลด...';
        try {
          startRes = await fetch(`/start_inference/${cam}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              ...camCfg,
              rois: payloadRois,
              interval,
              draw_page_boxes: true
            })
          });
          startData = await startRes.json().catch(() => ({}));
        } catch (err) {
          running = false;
          startButton.disabled = false;
          statusEl.innerText = 'เกิดข้อผิดพลาด';
          showAlert('Failed to start inference stream', 'error');
          return;
        }
        if(!startRes.ok || (startData.status!=='started' && startData.status!=='already_running')) {
          running = false;
          startButton.disabled = false;
          statusEl.innerText = 'เกิดข้อผิดพลาด';
          if (startData.message === 'open_failed') {
            showAlert('Failed to open video source', 'error');
          } else {
            showAlert('Failed to start inference stream', 'error');
          }
          return;
        }
        setStreamHealth({ state: 'starting' });
        statusEl.innerText = deriveStreamMessage('สำเร็จ');
        openSocket();
        if (hasAnyRoiEntry) {
          openRoiSocket();
          showAlert('Inference started', 'success');
        } else {
          showAlert('Camera started', 'success');
        }
        const logSourceName = cfg.name || name;
        startLogUpdates(logSourceName);
        setRunningUI();
      }

      const resetSocketReconnect = () => {
        socketReconnectAttempts = 0;
        clearTimeoutSafe(socketReconnectTimer);
        socketReconnectTimer = undefined;
      };

      const resetRoiSocketReconnect = () => {
        roiSocketReconnectAttempts = 0;
        clearTimeoutSafe(roiSocketReconnectTimer);
        roiSocketReconnectTimer = undefined;
      };

      const scheduleSocketReconnect = () => {
        if (!running) {
          return;
        }
        socketReconnectAttempts += 1;
        const delay = computeReconnectDelay(socketReconnectAttempts);
        clearTimeoutSafe(socketReconnectTimer);
        streamActive = false;
        statusEl.innerText = deriveStreamMessage('เชื่อมต่อภาพใหม่...');
        socketReconnectTimer = setTimeout(() => {
          if (!running) {
            return;
          }
          openSocket();
        }, delay);
      };

      const scheduleRoiSocketReconnect = () => {
        if (!running) {
          return;
        }
        roiSocketReconnectAttempts += 1;
        const delay = computeReconnectDelay(roiSocketReconnectAttempts);
        clearTimeoutSafe(roiSocketReconnectTimer);
        roiSocketReconnectTimer = setTimeout(() => {
          if (!running) {
            return;
          }
          openRoiSocket();
        }, delay);
      };

      async function stopInference(options = {}) {
        const opts = options && typeof options === 'object' ? options : {};
        const forceStop = Boolean(opts.force);
        const silent = Boolean(opts.silent);
        if (!running && !forceStop) {
          startButton.disabled = false;
          stopButton.disabled = true;
          return;
        }
        const wasRunning = running;
        running = false;
        resetSocketReconnect();
        resetRoiSocketReconnect();
        try {
          if (wasRunning || forceStop) {
            await fetchWithStatus(`/stop_inference/${cam}`, { method: 'POST' });
          }
        } catch (err) {
          if (!silent) {
            console.error('Failed to stop inference stream', err);
            showAlert('Failed to stop inference stream', 'error');
          }
        }
        if (socket) {
          socket.close();
          socket = null;
        }
        if (roiSocket) {
          roiSocket.close();
          roiSocket = null;
        }
        clearFrameWatchdog();
        stopLogUpdates();
        clearCanvas();
        video.width = 0;
        video.height = 0;
        queueFrameForRender(null);
        rois = [];
        allRois = [];
        roiGrid.innerHTML = '';
        resetScoreboard();
        roiGroupIndex = new Map();
        activeGroupName = '';
        streamActive = false;
        setStreamHealth({ state: 'stopped' });
        statusEl.innerText = deriveStreamMessage('Stopped');
        startButton.innerText = 'Resume';
        startButton.disabled = false;
        stopButton.disabled = true;
        updateLogRoiOptions([]);
        if (!silent) {
          showAlert('Inference stopped', 'info');
        }
      }

      function openSocket() {
        const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
        const wsBase = `${wsScheme}://${location.host}`;
        clearTimeoutSafe(socketReconnectTimer);
        socketReconnectTimer = undefined;
        const ws = new WebSocket(`${wsBase}/ws/${cam}`);
        ws.binaryType = 'blob';
        ws.onopen = () => {
          if (!running) {
            try { ws.close(); } catch (e) { /* noop */ }
            return;
          }
          if (socket && socket !== ws) {
            try { ws.close(); } catch (e) { /* noop */ }
            return;
          }
          socketReconnectAttempts = 0;
          streamActive = false;
          setStreamHealth({ state: 'starting' });
          statusEl.innerText = deriveStreamMessage('กำลังรับสตรีมภาพ...');
          scheduleFrameWatchdog(ws);
        };
        ws.onmessage = event => {
          streamActive = true;
          setStreamHealth({ state: 'active' });
          statusEl.innerText = deriveStreamMessage('Running');
          scheduleFrameWatchdog(ws);
          const blob = toFrameBlob(event.data);
          if (!blob) {
            return;
          }
          queueFrameForRender(blob);
        };
        ws.onerror = () => {
          if (socket === ws) {
            try { ws.close(); } catch (e) { /* noop */ }
          }
        };
        ws.onclose = event => {
          if (socket === ws) {
            socket = null;
            clearFrameWatchdog();
          }
          if (!running) {
            return;
          }
          const normalClose = event && (event.code === 1000 || event.code === 1001);
          if (normalClose) {
            setStreamHealth({ state: 'stopped' });
            statusEl.innerText = deriveStreamMessage('สตรีมหยุด');
            return;
          }
          if (event && event.code === 1012) {
            setStreamHealth({ state: 'outage' });
            statusEl.innerText = deriveStreamMessage('สตรีมภาพขาดหาย กำลังเชื่อมใหม่...');
          }
          scheduleSocketReconnect();
        };
        socket = ws;
      }

      function openRoiSocket() {
        const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
        const wsBase = `${wsScheme}://${location.host}`;
        clearTimeoutSafe(roiSocketReconnectTimer);
        roiSocketReconnectTimer = undefined;
        const ws = new WebSocket(`${wsBase}/ws_roi_result/${cam}`);
        ws.onopen = () => {
          if (!running) {
            try { ws.close(); } catch (e) { /* noop */ }
            return;
          }
          if (roiSocket && roiSocket !== ws) {
            try { ws.close(); } catch (e) { /* noop */ }
            return;
          }
          roiSocketReconnectAttempts = 0;
        };
        ws.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            if ('group' in data || Array.isArray(data.scores)) {
              setTimeout(() => {
                handlePageSummaryUpdate(data.group, data.scores);
              }, 0);
            }
            if (Array.isArray(data.results)) {
              const fallbackFrameTime =
                typeof data.frame_time === 'number' ? data.frame_time : undefined;
              setTimeout(() => {
                data.results.forEach(item => applyRoiResult(item, fallbackFrameTime));
              }, 0);
            } else if (Object.prototype.hasOwnProperty.call(data, 'id')) {
              setTimeout(() => {
                applyRoiResult(data);
              }, 0);
            }
          } catch (e) {
            console.error('ROI message error', e);
          }
        };
        ws.onerror = () => {
          if (roiSocket === ws) {
            try { ws.close(); } catch (e) { /* noop */ }
          }
        };
        ws.onclose = event => {
          if (roiSocket === ws) {
            roiSocket = null;
          }
          if (!running) {
            return;
          }
          const normalClose = event && (event.code === 1000 || event.code === 1001);
          if (normalClose) {
            return;
          }
          scheduleRoiSocketReconnect();
        };
        roiSocket = ws;
      }

      async function checkStatus() {
        let name = sourceSelect.value || '';
        const res = await fetchWithStatus(`/inference_status/${cam}`);
        const data = await res.json();
        setStreamHealth(data.stream_health);
        const statusSource = typeof data.source === 'string' ? data.source : '';
        const statusGroupRaw = typeof data.group === 'string' ? data.group : '';
        const normalizedStatusGroup = normalizeGroupName(statusGroupRaw);
        if (statusSource) {
          const options = Array.from(sourceSelect.options || []);
          const hasOption = options.some(opt => opt.value === statusSource);
          if (!hasOption) {
            const opt = document.createElement('option');
            opt.value = statusSource;
            opt.textContent = statusSource;
            sourceSelect.appendChild(opt);
          }
          if (sourceSelect.value !== statusSource) {
            sourceSelect.value = statusSource;
            storeValue('source', statusSource);
            updateHeaderSourceLabel();
          }
        }
        if (!name && statusSource) {
          name = statusSource;
          storeValue('source', statusSource);
          updateHeaderSourceLabel();
        }
        const shouldBeRunning = Boolean(data.running && name);
        if (shouldBeRunning) {
          running = true;
          streamActive = false;
          openSocket();
          const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
          const cfg = await cfgRes.json();
          let roiPath = cfg.rois;
          if (!roiPath.startsWith('/')) {
            roiPath = `data_sources/${cfg.name}/${roiPath}`;
          }
          const roiRes = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
          const roiData = await roiRes.json();
          const roiEntries = Array.isArray(roiData.rois) ? roiData.rois : [];
          allRois = roiEntries;
          rebuildRoiGroupIndex(roiEntries);
          resetScoreboard();
          if (normalizedStatusGroup) {
            setActiveGroup(normalizedStatusGroup);
            if (pageNameEl) {
              pageNameEl.textContent = normalizedStatusGroup;
            }
          }
          const hasAnyRoiEntry = roiEntries.length > 0;
          if (roiSocket) {
            roiSocket.close();
            roiSocket = null;
          }
          if (hasAnyRoiEntry) {
            openRoiSocket();
          }
          stopLogUpdates();
          const logSourceName = cfg.name || statusSource || name;
          startLogUpdates(logSourceName);
          setRunningUI();
        } else {
          running = false;
          streamActive = false;
          statusEl.innerText = deriveStreamMessage('Idle');
          startButton.innerText = 'Start';
          startButton.disabled = false;
          stopButton.disabled = true;
          stopLogUpdates();
          resetScoreboard();
        }
      }

      function setRunningUI() {
        const text = deriveStreamMessage('Running');
        statusEl.innerText = text && text.length > 0 ? text : 'Running';
        startButton.disabled = true;
        stopButton.disabled = false;
        startButton.innerText = 'Start';
      }

      function handlePageSummaryUpdate(groupName, scores) {
        const normalizedGroup = normalizeGroupName(groupName);
        if (pageNameEl) {
          pageNameEl.textContent = normalizedGroup || '-';
        }
        if (Array.isArray(scores)) {
          renderScoreboard(scores);
        }
        setActiveGroup(normalizedGroup);
      }

      (async () => {
        await loadSources();
        await checkStatus();
      })();

      return {
        stopInference,
        camId: cam,
        clearStoredValues() {
          ['source', 'interval'].forEach(key => {
            localStorage.removeItem(makeStorageKey(key));
          });
        },
      };
    }

    const inferenceRows = document.getElementById('pageInferenceRows');
    const addButton = document.getElementById('addPageInferenceBtn');
    const controllers = new Map();
    const camIdToCell = new Map();
    let nextCamIndex = 1;

    function sanitizeCellId(rawId) {
      const cleaned = (rawId || '').replace(/[^a-zA-Z0-9_-]/g, '_');
      return cleaned || `cam${nextCamIndex}`;
    }

    function ensureUniqueCellId(baseId) {
      let candidate = baseId;
      let counter = 1;
      while (controllers.has(candidate) || document.getElementById(candidate)) {
        candidate = `${baseId}_${counter++}`;
      }
      return candidate;
    }

    function updateNextIndexFromCellId(cellId) {
      const match = String(cellId || '').match(/(\d+)$/);
      if (match) {
        const value = parseInt(match[1], 10);
        if (!Number.isNaN(value) && value >= nextCamIndex) {
          nextCamIndex = value + 1;
        }
      }
    }

    function generateCellId() {
      let candidate;
      do {
        candidate = `cam${nextCamIndex++}`;
      } while (controllers.has(candidate) || document.getElementById(candidate));
      return candidate;
    }

    function createRowElement(cellId, titleText, camId) {
      const row = document.createElement('div');
      row.className = 'cam-row';
      if (inferenceRows.children.length > 0) {
        row.classList.add('mt-2');
      }
      row.dataset.cellId = cellId;
      row.innerHTML = `
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
          <div>
            <h5 class="mb-0" id="${cellId}-title">${titleText}</h5>
            <div class="text-muted small" id="${cellId}-label">ID: ${camId}</div>
          </div>
          <div class="d-flex gap-2 flex-wrap">
            <button type="button" class="btn btn-outline-danger btn-sm" data-action="remove" data-cell-id="${cellId}">ลบงานนี้</button>
          </div>
        </div>
        <div class="video-col">
          <div class="card roi-card video-card">
            <div id="${cellId}" class="cam-cell">
              <div class="d-flex align-items-center mb-2 gap-2 menu-select-list flex-wrap">
                <label for="${cellId}-sourceSelect" class="form-label mb-0">Source:</label>
                <select id="${cellId}-sourceSelect" class="form-select w-auto"></select>
                <label for="${cellId}-intervalInput" class="form-label mb-0">Time (interval):</label>
                <input id="${cellId}-intervalInput" type="number" class="form-control w-auto" min="0" step="0.1" value="1" />
              </div>
              <div class="d-flex align-items-center gap-2 flex-wrap mb-2">
                <button id="${cellId}-startButton" class="btn btn-primary">Start</button>
                <button id="${cellId}-stopButton" class="btn btn-danger" disabled>Stop</button>
                <div class="ms-auto text-muted small" id="${cellId}-status"></div>
              </div>
              <div class="video-wrapper">
                <canvas id="${cellId}-video" class="stream-video"></canvas>
              </div>
            </div>
          </div>
          <div class="card page-summary-card">
            <div class="d-flex align-items-start justify-content-between flex-wrap gap-3 mb-2">
              <div>
                <h6 class="mb-1">ผลการจับหน้าล่าสุด</h6>
                <p class="mb-0 text-muted small">เรียงตามคะแนนสูงสุดจากงานนี้</p>
              </div>
              <div class="page-score-chip text-end">
                <div class="text-muted small">หน้าปัจจุบัน</div>
                <div class="page-score-current" id="${cellId}-pageName">-</div>
              </div>
            </div>
            <div class="page-score-body">
              <div id="${cellId}-pageScoresEmpty" class="page-score-empty">ยังไม่มีผลคะแนน</div>
              <div id="${cellId}-pageScoresWrapper" class="table-responsive page-score-table d-none">
                <table id="${cellId}-pageScores" class="table table-striped table-sm mb-0">
                  <thead><tr><th>Page</th><th>Score</th></tr></thead>
                  <tbody id="${cellId}-pageScoresBody"></tbody>
                </table>
              </div>
            </div>
          </div>
          <div class="card roi-card log-card">
            <div class="d-flex align-items-center mb-2 gap-2 menu-select-list">
              <label for="${cellId}-logRoiSelect" class="form-label mb-0">ROI:</label>
              <select id="${cellId}-logRoiSelect" class="form-select w-auto"></select>
            </div>
            <div class="log-wrapper">
              <table id="${cellId}-logTable" class="table table-striped">
                <thead><tr><th>Log</th></tr></thead>
                <tbody id="${cellId}-logBody"></tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="card roi-card roi-list-card">
          <div id="${cellId}-rois" class="roi-grid"></div>
        </div>`;
      inferenceRows.appendChild(row);
      return row;
    }

    function addInferenceRow({ cellId, camId, title, defaultSource, defaultInterval } = {}) {
      let desiredCellId = cellId ? sanitizeCellId(cellId) : '';
      if (desiredCellId) {
        desiredCellId = ensureUniqueCellId(desiredCellId);
        updateNextIndexFromCellId(desiredCellId);
      }
      const actualCellId = desiredCellId || generateCellId();
      const actualCamId = typeof camId === 'string' && camId.length > 0
        ? camId
        : `page_${actualCellId}`;
      const displayTitle = title || `งาน Page Inference ${controllers.size + 1}`;
      createRowElement(actualCellId, displayTitle, actualCamId);
      initRoiLayout(actualCellId);
      const controller = createCameraController(actualCellId, {
        camId: actualCamId,
        title: displayTitle,
        defaultSource,
        defaultInterval,
      });
      controllers.set(actualCellId, controller);
      camIdToCell.set(actualCamId, actualCellId);
      return actualCellId;
    }

    async function removeInferenceRow(cellId) {
      const controller = controllers.get(cellId);
      if (controller && typeof controller.stopInference === 'function') {
        try {
          await controller.stopInference({ force: true, silent: true });
        } catch (err) {
          console.warn('Failed to stop inference before removal', err);
        }
      }
      controllers.delete(cellId);
      if (controller && controller.camId) {
        camIdToCell.delete(controller.camId);
      }
      if (controller && typeof controller.clearStoredValues === 'function') {
        controller.clearStoredValues();
      }
      const row = inferenceRows.querySelector(`.cam-row[data-cell-id="${cellId}"]`);
      if (row) {
        row.remove();
      }
      showAlert('ลบงาน Inference แล้ว', 'info');
      if (controllers.size === 0) {
        addInferenceRow();
      }
    }

    addButton.addEventListener('click', () => {
      const cellId = addInferenceRow();
      showAlert('สร้างงาน Inference ใหม่แล้ว', 'success');
      const sourceSelect = document.getElementById(`${cellId}-sourceSelect`);
      if (sourceSelect) {
        sourceSelect.focus();
      }
    });

    inferenceRows.addEventListener('click', async event => {
      const button = event.target.closest('[data-action="remove"]');
      if (!button) {
        return;
      }
      const cellId = button.getAttribute('data-cell-id');
      if (!cellId) {
        return;
      }
      const confirmed = window.confirm('ต้องการลบงาน Inference นี้หรือไม่? ระบบจะหยุดการประมวลผลให้ทันที');
      if (!confirmed) {
        return;
      }
      await removeInferenceRow(cellId);
    });

    async function bootstrapExisting() {
      let createdAny = false;
      try {
        const res = await fetch('/api/dashboard');
        if (res.ok) {
          const payload = await res.json();
          const cameras = Array.isArray(payload?.cameras) ? payload.cameras : [];
          cameras
            .filter(cam => (
              typeof cam?.cam_id === 'string'
              && cam.cam_id.startsWith('page_')
              && cam.inference_running
            ))
            .forEach(cam => {
              const camId = cam.cam_id;
              if (camIdToCell.has(camId)) {
                return;
              }
              const rawCell = camId.replace(/^page_/, '') || camId;
              const cellId = addInferenceRow({
                cellId: rawCell,
                camId,
                title: cam.name || camId,
                defaultSource: cam.name || '',
                defaultInterval: cam.interval,
              });
              createdAny = true;
            });
        }
      } catch (err) {
        console.warn('ไม่สามารถโหลดงาน Inference ที่มีอยู่ได้', err);
      }
      if (!createdAny && controllers.size === 0) {
        addInferenceRow();
      }
    }

    bootstrapExisting();
  })();
</script>
