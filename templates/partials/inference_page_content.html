<div class="d-flex flex-column gap-3">
  <div class="d-flex align-items-start justify-content-between flex-wrap gap-3">
    <div>
      <h4 class="mb-1">จัดการงาน Inference สำหรับหน้าเอกสาร</h4>
      <p class="mb-0 text-muted">สร้างหลายงานได้พร้อมกันเพื่อทดสอบการตรวจจับหน้าและ ROI ได้อย่างยืดหยุ่น</p>
    </div>
    <div class="d-flex gap-2 flex-wrap">
      <button type="button" id="addPageInferenceBtn" class="btn btn-success">เพิ่มงาน Inference</button>
    </div>
  </div>
  <div class="alert alert-info" role="alert">
    <ul class="mb-0 ps-3">
      <li>แต่ละงานสามารถเลือก Source, Group และกำหนด Interval เป็นของตัวเองได้</li>
      <li>ผลการจับหน้านั้นจะแสดงชื่อหน้าและคะแนนของแต่ละหน้าแยกตามงาน</li>
      <li>เมื่อลบงาน ระบบจะหยุดการประมวลผลและเคลียร์ข้อมูลให้โดยอัตโนมัติ</li>
    </ul>
  </div>
  <div id="pageInferenceRows" class="d-flex flex-column gap-4"></div>
</div>
<script>
  (function() {
    function initRoiLayout(cellId) {
      const videoCell = document.getElementById(cellId);
      const videoCol = videoCell ? videoCell.closest('.video-col') : null;
      const roiContainer = document.getElementById(`${cellId}-rois`);
      const roiCard = roiContainer ? roiContainer.closest('.roi-list-card') : null;
      if (!videoCol || !roiCard) {
        return;
      }

      const roiGrid = roiCard.querySelector('.roi-grid');
      if (roiGrid) {
        roiGrid.style.height = '100%';
      }

      const updateHeight = () => {
        const rect = videoCol.getBoundingClientRect();
        if (rect && rect.height) {
          roiCard.style.maxHeight = `${rect.height}px`;
        }
      };

      updateHeight();

      if ('ResizeObserver' in window) {
        const observer = new ResizeObserver(() => updateHeight());
        observer.observe(videoCol);
      }

      window.addEventListener('resize', updateHeight);
    }

    function createCameraController(cellId, options = {}) {
      let socket;
      let roiSocket;
      let rois = [];
      let allRois = [];
      let running = false;
      const {
        camId: camIdOverride,
        title: providedTitle,
        defaultSource: providedSource,
        defaultInterval,
      } = options || {};
      const cam = typeof camIdOverride === 'string' && camIdOverride.length > 0
        ? camIdOverride
        : `page_${cellId}`;
      const getEl = suffix => document.getElementById(`${cellId}-${suffix}`);
      const video = getEl('video');
      const videoCtx = video.getContext('2d');
      const startButton = getEl('startButton');
      const stopButton = getEl('stopButton');
      const statusEl = getEl('status');
      const titleEl = getEl('title');
      const labelEl = getEl('label');
      const sourceSelect = getEl('sourceSelect');
      const roiGrid = getEl('rois');
      const logBody = getEl('logBody');
      const logRoiSelect = getEl('logRoiSelect');
      const intervalInput = getEl('intervalInput');
      const pageNameEl = getEl('pageName');
      const scoreTableBody = getEl('pageScoresBody');
      const scoreTableWrapper = getEl('pageScoresWrapper');
      const scoreEmptyEl = getEl('pageScoresEmpty');
      let logTimer;
      let isLogUpdating = false;
      let logSessionId = 0;
      let currentLogSource;
      const baseTitle = typeof providedTitle === 'string' && providedTitle.length > 0
        ? providedTitle
        : 'งาน Inference';
      if (titleEl) {
        titleEl.textContent = baseTitle;
      }
      const baseLabelText = `ID: ${cam}`;
      if (labelEl) {
        labelEl.textContent = baseLabelText;
      }
      const storedInterval = localStorage.getItem(`${cellId}-interval`);
      if (storedInterval) {
        intervalInput.value = storedInterval;
      } else if (defaultInterval !== undefined && defaultInterval !== null) {
        intervalInput.value = String(defaultInterval);
      } else {
        intervalInput.value = '1';
      }

      const formatTs = ts => {
        if (!ts) return '';
        const d = new Date(ts * 1000);
        const ms = String(d.getMilliseconds()).padStart(3, '0');
        return `${d.toLocaleTimeString('th-TH', { hour12: false })}.${ms}`;
      };

      const formatDuration = seconds => {
        if (!Number.isFinite(seconds) || seconds < 0) return '';
        if (seconds >= 1) {
          return `${seconds.toFixed(2)} s`;
        }
        if (seconds >= 0.001) {
          return `${Math.round(seconds * 1000)} ms`;
        }
        return `${(seconds * 1000).toFixed(2)} ms`;
      };

      const renderScoreboard = (scores = []) => {
        if (!scoreTableBody) {
          return;
        }
        scoreTableBody.innerHTML = '';
        const list = Array.isArray(scores) ? scores : [];
        list.forEach(item => {
          const tr = document.createElement('tr');
          const tdPage = document.createElement('td');
          tdPage.textContent = item?.page ?? '';
          const tdScore = document.createElement('td');
          const scoreValue = typeof item?.score === 'number' ? item.score : null;
          tdScore.textContent = scoreValue !== null ? scoreValue.toFixed(2) : '';
          tr.appendChild(tdPage);
          tr.appendChild(tdScore);
          scoreTableBody.appendChild(tr);
        });
        const hasScores = list.length > 0;
        if (scoreTableWrapper) {
          scoreTableWrapper.classList.toggle('d-none', !hasScores);
        }
        if (scoreEmptyEl) {
          scoreEmptyEl.classList.toggle('d-none', hasScores);
        }
      };

      const resetScoreboard = () => {
        if (pageNameEl) {
          pageNameEl.textContent = '-';
        }
        renderScoreboard([]);
      };
      resetScoreboard();

      const updateHeaderSourceLabel = () => {
        if (!labelEl) {
          return;
        }
        const sourceName = sourceSelect.value || '';
        labelEl.textContent = sourceName
          ? `${baseLabelText} • Source: ${sourceName}`
          : baseLabelText;
      };

      sourceSelect.onchange = () => {
        localStorage.setItem(`${cellId}-source`, sourceSelect.value);
        updateHeaderSourceLabel();
      };

      startButton.onclick = () => { startInference(); };
      stopButton.onclick = () => { stopInference(); };
      logRoiSelect.onchange = () => {
        if (currentLogSource) {
          startLogUpdates(currentLogSource);
        }
      };

      async function fetchWithStatus(url, options = {}) {
        statusEl.innerText = 'กำลังโหลด...';
        try {
          const res = await fetch(url, options);
          if (!res.ok) throw new Error('network');
          statusEl.innerText = 'สำเร็จ';
          return res;
        } catch (err) {
          statusEl.innerText = 'เกิดข้อผิดพลาด';
          throw err;
        }
      }

      async function loadSources() {
        try {
          const res = await fetchWithStatus('/source_list');
          if (!res.ok) throw new Error('Bad response');
          const data = await res.json();
          sourceSelect.innerHTML = '';
          if (data.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'No sources available';
            sourceSelect.appendChild(opt);
            statusEl.innerText = 'Create a source first';
            showAlert('No sources available', 'error');
          } else {
            data.forEach(item => {
              const opt = document.createElement('option');
              opt.value = item.name;
              opt.textContent = item.name;
              sourceSelect.appendChild(opt);
            });
            const stored = localStorage.getItem(`${cellId}-source`) || '';
            const preferredSource = stored
              || (typeof providedSource === 'string' ? providedSource : '');
            const availableSources = new Set(data.map(item => item.name));
            if (preferredSource && availableSources.has(preferredSource)) {
              sourceSelect.value = preferredSource;
              localStorage.setItem(`${cellId}-source`, preferredSource);
            }
            updateHeaderSourceLabel();
            showAlert('Sources loaded', 'success');
          }
        } catch (err) {
          console.error('Failed to load sources', err);
          sourceSelect.innerHTML = '';
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'Error loading sources';
          sourceSelect.appendChild(opt);
          statusEl.innerText = 'Error fetching sources';
          showAlert('Failed to load sources', 'error');
          updateHeaderSourceLabel();
        }
      }

      const getModuleElementId = id => `${cellId}-module-${id}`;

      function findRoiDataById(id) {
        const key = String(id);
        const match = rois.find(r => String(r?.id) === key);
        if (match) return match;
        return allRois.find(r => String(r?.id) === key) || null;
      }

      function normalizeModule(value) {
        return typeof value === 'string' ? value.trim() : '';
      }

      function updateRoiModuleLabel(id, override = '') {
        const moduleEl = document.getElementById(getModuleElementId(id));
        if (!moduleEl) return;
        const overrideText = normalizeModule(override);
        const fallback = normalizeModule(findRoiDataById(id)?.module ?? '');
        const moduleName = overrideText || fallback;
        moduleEl.textContent = moduleName ? `โมดูล: ${moduleName}` : 'โมดูล: -';
      }

      function isRoiType(data) {
        return (data?.type ?? 'roi') === 'roi';
      }

      function ensureRoiItem(id) {
        if (document.getElementById(`${cellId}-roi-${id}`)) return;
        const r = findRoiDataById(id) || { id };
        if (!isRoiType(r)) {
          return;
        }
        const item = document.createElement('div');
        item.className = 'roi-item';
        const title = document.createElement('h4');
        title.className = 'roi-title';
        title.textContent = r.name || `ROI ${id}`;
        const img = document.createElement('img');
        img.id = `${cellId}-roi-${id}`;
        img.className = 'roi-image';
        const moduleLine = document.createElement('p');
        moduleLine.id = getModuleElementId(id);
        moduleLine.className = 'roi-module';
        const t = document.createElement('p');
        t.id = `${cellId}-time-${id}`;
        t.className = 'roi-time';
        const p = document.createElement('p');
        p.id = `${cellId}-text-${id}`;
        p.className = 'roi-text';
        item.appendChild(title);
        item.appendChild(img);
        item.appendChild(moduleLine);
        item.appendChild(t);
        item.appendChild(p);
        roiGrid.appendChild(item);
        updateRoiModuleLabel(id);
      }

      function applyRoiResult(result, fallbackFrameTime) {
        if (!result) return;
        const roiId = result.id;
        if (roiId === undefined || roiId === null) return;
        const roiData = findRoiDataById(roiId);
        if (roiData && !isRoiType(roiData)) {
          return;
        }
        ensureRoiItem(roiId);
        updateRoiModuleLabel(roiId, result.module);
        const imgEl = document.getElementById(`${cellId}-roi-${roiId}`);
        if (imgEl && Object.prototype.hasOwnProperty.call(result, 'image')) {
          imgEl.src = result.image ? `data:image/jpeg;base64,${result.image}` : '';
        }
        const textEl = document.getElementById(`${cellId}-text-${roiId}`);
        if (textEl) {
          const text = result.text ?? '';
          textEl.textContent = text ? `ข้อความ: ${text}` : 'ข้อความ: -';
        }
        const timeEl = document.getElementById(`${cellId}-time-${roiId}`);
        if (timeEl) {
          const duration = typeof result.duration === 'number'
            ? result.duration
            : Number.NaN;
          const durationText = formatDuration(duration);
          if (durationText) {
            timeEl.textContent = `เวลา: ${durationText}`;
          } else {
            const ts = typeof result.frame_time === 'number'
              ? result.frame_time
              : fallbackFrameTime;
            timeEl.textContent = ts ? `เวลา: ${formatTs(ts)}` : '';
          }
        }
      }

      function startLogUpdates(sourceName){
        currentLogSource = sourceName;
        stopLogUpdates();
        const sessionId = logSessionId;
        isLogUpdating = true;
        async function fetchLog(){
          if(!isLogUpdating || sessionId !== logSessionId){
            return;
          }
          try{
            const res=await fetch(`/read_log?source=${encodeURIComponent(sourceName)}&lines=40&_=${Date.now()}`);
            const data=await res.json();
            if(sessionId !== logSessionId){
              return;
            }
            const selectedRoi=logRoiSelect.value;
            logBody.innerHTML='';
            const lines=(data.lines||[]).slice().reverse();
            lines.forEach(line=>{
              const marker='AGGREGATED_ROI ';
              const idx=line.indexOf(marker);
              if(idx!==-1){
                const prefix=line.slice(0,idx).trim();
                const payload=line.slice(idx+marker.length).trim();
                try{
                  const parsed=JSON.parse(payload);
                  const results=Array.isArray(parsed.results)?parsed.results:[];
                  const frameTs=typeof parsed.frame_time==='number'?parsed.frame_time:null;
                  const resultTs=typeof parsed.result_time==='number'?parsed.result_time:null;
                  const groupLabel=parsed.group||'';
                  results.forEach(res=>{
                    const roiId=res?.id??res?.roi_id??res?.ROI_ID;
                    if(roiId===undefined||roiId===null)return;
                    if(selectedRoi!=='all'&&String(roiId)!==selectedRoi)return;
                    const tr=document.createElement('tr');
                    const td=document.createElement('td');
                    const parts=[];
                    if(prefix)parts.push(prefix);
                    if(frameTs)parts.push(`frame=${formatTs(frameTs)}`);
                    if(resultTs)parts.push(`result=${formatTs(resultTs)}`);
                    parts.push(`roi_id=${roiId}`);
                    if(res.name)parts.push(`name=${res.name}`);
                    const moduleName=typeof res.module==='string'?res.module.trim():'';
                    if(moduleName)parts.push(`module=${moduleName}`);
                    if(groupLabel)parts.push(`group=${groupLabel}`);
                    if(typeof res.duration==='number'){
                      const dur=formatDuration(res.duration);
                      if(dur)parts.push(`duration=${dur}`);
                    }
                    const textValue=typeof res.text==='string'?res.text:'';
                    parts.push(`text=${textValue}`);
                    td.textContent=parts.join(' | ');
                    tr.appendChild(td);
                    logBody.appendChild(tr);
                  });
                  return;
                }catch(e){}
              }
              if(selectedRoi==='all'||line.includes(`roi_id=${selectedRoi}`)){
                const tr=document.createElement('tr');
                const td=document.createElement('td');
                td.textContent=line;
                tr.appendChild(td);
                logBody.appendChild(tr);
              }
            });
          }catch(e){}
          finally{
            if(isLogUpdating && sessionId === logSessionId){
              logTimer=setTimeout(fetchLog,1000);
            }
          }
        }
        fetchLog();
      }

      function stopLogUpdates(){
        isLogUpdating=false;
        logSessionId++;
        if(logTimer){
          clearTimeout(logTimer);
          logTimer=null;
        }
        logBody.innerHTML='';
      }

      function updateLogRoiOptions(list){
        logRoiSelect.innerHTML='';
        const optAll=document.createElement('option');
        optAll.value='all';
        optAll.textContent='All';
        logRoiSelect.appendChild(optAll);
        list.forEach(r=>{
          const opt=document.createElement('option');
          opt.value=r.id;
          opt.textContent=r.id;
          logRoiSelect.appendChild(opt);
        });
      }

      async function startInference(roisOverride = null) {
        if (running) return;
        running = true;
        startButton.disabled = true;
        const name = sourceSelect.value;
        if (!name) {
          statusEl.innerText = 'Select source first';
          running = false;
          startButton.disabled = false;
          showAlert('Select source first', 'error');
          return;
        }
        localStorage.setItem(`${cellId}-source`, name);

        const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
        const cfg = await cfgRes.json();

        const { module: _unused, rois: roiPathRaw, ...camCfg } = cfg;
        const interval = parseFloat(intervalInput.value) || 1;
        localStorage.setItem(`${cellId}-interval`, interval);
        let roiPath = roiPathRaw;
        if (!roiPath.startsWith('/')) {
          roiPath = `data_sources/${cfg.name}/${roiPath}`;
        }
        const res = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
        const data = await res.json();
        statusEl.innerText = '';
        allRois = data.rois || [];
        const roiList = allRois.filter(r => (r.type ?? 'roi') === 'roi');
        if (Array.isArray(roisOverride)) {
          rois = roisOverride;
        } else {
          rois = roiList;
        }
        updateLogRoiOptions(roiList);
        roiGrid.innerHTML = '';
        resetScoreboard();
        rois.forEach(r => {
          if (r && r.id !== undefined && r.id !== null) {
            ensureRoiItem(r.id);
            updateRoiModuleLabel(r.id);
          }
        });

        let startData;
        let startRes;
        statusEl.innerText = 'กำลังโหลด...';
        try {
          startRes = await fetch(`/start_inference/${cam}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              ...camCfg,
              rois,
              interval,
              draw_page_boxes: false
            })
          });
          startData = await startRes.json().catch(() => ({}));
        } catch (err) {
          running = false;
          startButton.disabled = false;
          statusEl.innerText = 'เกิดข้อผิดพลาด';
          showAlert('Failed to start inference stream', 'error');
          return;
        }
        if(!startRes.ok || (startData.status!=='started' && startData.status!=='already_running')) {
          running = false;
          startButton.disabled = false;
          statusEl.innerText = 'เกิดข้อผิดพลาด';
          if (startData.message === 'open_failed') {
            showAlert('Failed to open video source', 'error');
          } else {
            showAlert('Failed to start inference stream', 'error');
          }
          return;
        }
        statusEl.innerText = 'สำเร็จ';
        openSocket();
        if (rois.length > 0) {
          openRoiSocket();
          showAlert('Inference started', 'success');
        } else {
          showAlert('Camera started', 'success');
        }
        startLogUpdates(cfg.name);
        setRunningUI();
      }

      async function stopInference(options = {}) {
        const opts = options && typeof options === 'object' ? options : {};
        const forceStop = Boolean(opts.force);
        const silent = Boolean(opts.silent);
        if (!running && !forceStop) {
          startButton.disabled = false;
          stopButton.disabled = true;
          return;
        }
        const wasRunning = running;
        running = false;
        try {
          if (wasRunning || forceStop) {
            await fetchWithStatus(`/stop_inference/${cam}`, { method: 'POST' });
          }
        } catch (err) {
          if (!silent) {
            console.error('Failed to stop inference stream', err);
            showAlert('Failed to stop inference stream', 'error');
          }
        }
        if (socket) {
          socket.close();
          socket = null;
        }
        if (roiSocket) {
          roiSocket.close();
          roiSocket = null;
        }
        stopLogUpdates();
        if (videoCtx) {
          videoCtx.clearRect(0, 0, video.width || 0, video.height || 0);
        }
        video.width = 0;
        video.height = 0;
        rois = [];
        allRois = [];
        roiGrid.innerHTML = '';
        resetScoreboard();
        statusEl.innerText = 'Stopped';
        startButton.innerText = 'Resume';
        startButton.disabled = false;
        stopButton.disabled = true;
        updateLogRoiOptions([]);
        if (!silent) {
          showAlert('Inference stopped', 'info');
        }
      }

      function openSocket() {
        const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
        const wsBase = `${wsScheme}://${location.host}`;
        socket = new WebSocket(`${wsBase}/ws/${cam}`);
        socket.binaryType = 'blob';
        socket.onmessage = async function(event) {
          try {
            const bitmap = await createImageBitmap(event.data);
            if (video.width !== bitmap.width || video.height !== bitmap.height) {
              video.width = bitmap.width;
              video.height = bitmap.height;
            }
            if (videoCtx) {
              videoCtx.clearRect(0, 0, video.width, video.height);
              videoCtx.drawImage(bitmap, 0, 0);
            }
            bitmap.close();
          } catch (err) {
            console.error('Failed to render frame', err);
          }
        };
      }

      function openRoiSocket() {
        const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
        const wsBase = `${wsScheme}://${location.host}`;
        roiSocket = new WebSocket(`${wsBase}/ws_roi_result/${cam}`);
        roiSocket.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            if ('group' in data || Array.isArray(data.scores)) {
              setTimeout(() => {
                if (pageNameEl) {
                  pageNameEl.textContent = data.group || '-';
                }
                renderScoreboard(data.scores);
              }, 0);
            }
            if (Array.isArray(data.results)) {
              const fallbackFrameTime =
                typeof data.frame_time === 'number' ? data.frame_time : undefined;
              setTimeout(() => {
                data.results.forEach(item => applyRoiResult(item, fallbackFrameTime));
              }, 0);
            } else if (Object.prototype.hasOwnProperty.call(data, 'id')) {
              setTimeout(() => {
                applyRoiResult(data);
              }, 0);
            }
          } catch (e) {
            console.error('ROI message error', e);
          }
        };
      }

      async function checkStatus() {
        const name = sourceSelect.value;
        const res = await fetchWithStatus(`/inference_status/${cam}`);
        const data = await res.json();
        if (data.running && name) {
          openSocket();
          const cfgRes = await fetchWithStatus(`/source_config?name=${encodeURIComponent(name)}`);
          const cfg = await cfgRes.json();
          let roiPath = cfg.rois;
          if (!roiPath.startsWith('/')) {
            roiPath = `data_sources/${cfg.name}/${roiPath}`;
          }
          const roiRes = await fetchWithStatus(`/load_roi_file?path=${encodeURIComponent(roiPath)}`);
          const roiData = await roiRes.json();
          allRois = roiData.rois || [];
          const roiList = allRois.filter(r => (r.type ?? 'roi') === 'roi');
          rois = roiList;
          updateLogRoiOptions(roiList);
          roiGrid.innerHTML = '';
          rois.forEach(r => {
            if (r && r.id !== undefined && r.id !== null) {
              ensureRoiItem(r.id);
              updateRoiModuleLabel(r.id);
            }
          });
          if (roiSocket) {
            roiSocket.close();
            roiSocket = null;
          }
          openRoiSocket();
          stopLogUpdates();
          startLogUpdates(cfg.name);
          setRunningUI();
          running = true;
        } else {
          statusEl.innerText = 'Idle';
          startButton.innerText = 'Start';
          startButton.disabled = false;
          stopButton.disabled = true;
          running = false;
          stopLogUpdates();
          resetScoreboard();
        }
      }

      function setRunningUI() {
        statusEl.innerText = 'Running';
        startButton.disabled = true;
        stopButton.disabled = false;
        startButton.innerText = 'Start';
      }

      (async () => {
        await loadSources();
        await checkStatus();
      })();

      return { stopInference, camId: cam };
    }

    const inferenceRows = document.getElementById('pageInferenceRows');
    const addButton = document.getElementById('addPageInferenceBtn');
    const controllers = new Map();
    const camIdToCell = new Map();
    let nextCamIndex = 1;

    function sanitizeCellId(rawId) {
      const cleaned = (rawId || '').replace(/[^a-zA-Z0-9_-]/g, '_');
      return cleaned || `cam${nextCamIndex}`;
    }

    function ensureUniqueCellId(baseId) {
      let candidate = baseId;
      let counter = 1;
      while (controllers.has(candidate) || document.getElementById(candidate)) {
        candidate = `${baseId}_${counter++}`;
      }
      return candidate;
    }

    function updateNextIndexFromCellId(cellId) {
      const match = String(cellId || '').match(/(\d+)$/);
      if (match) {
        const value = parseInt(match[1], 10);
        if (!Number.isNaN(value) && value >= nextCamIndex) {
          nextCamIndex = value + 1;
        }
      }
    }

    function generateCellId() {
      let candidate;
      do {
        candidate = `cam${nextCamIndex++}`;
      } while (controllers.has(candidate) || document.getElementById(candidate));
      return candidate;
    }

    function createRowElement(cellId, titleText, camId) {
      const row = document.createElement('div');
      row.className = 'cam-row';
      if (inferenceRows.children.length > 0) {
        row.classList.add('mt-2');
      }
      row.dataset.cellId = cellId;
      row.innerHTML = `
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
          <div>
            <h5 class="mb-0" id="${cellId}-title">${titleText}</h5>
            <div class="text-muted small" id="${cellId}-label">ID: ${camId}</div>
          </div>
          <div class="d-flex gap-2 flex-wrap">
            <button type="button" class="btn btn-outline-danger btn-sm" data-action="remove" data-cell-id="${cellId}">ลบงานนี้</button>
          </div>
        </div>
        <div class="video-col">
          <div class="card roi-card video-card">
            <div id="${cellId}" class="cam-cell">
              <div class="d-flex align-items-center mb-2 gap-2 menu-select-list flex-wrap">
                <label for="${cellId}-sourceSelect" class="form-label mb-0">Source:</label>
                <select id="${cellId}-sourceSelect" class="form-select w-auto"></select>
                <label for="${cellId}-intervalInput" class="form-label mb-0">Time (interval):</label>
                <input id="${cellId}-intervalInput" type="number" class="form-control w-auto" min="0" step="0.1" value="1" />
              </div>
              <div class="d-flex align-items-center gap-2 flex-wrap mb-2">
                <button id="${cellId}-startButton" class="btn btn-primary">Start</button>
                <button id="${cellId}-stopButton" class="btn btn-danger" disabled>Stop</button>
                <div class="ms-auto text-muted small" id="${cellId}-status"></div>
              </div>
              <div class="video-wrapper">
                <canvas id="${cellId}-video" class="stream-video"></canvas>
              </div>
            </div>
          </div>
          <div class="card page-summary-card">
            <div class="d-flex align-items-start justify-content-between flex-wrap gap-3 mb-2">
              <div>
                <h6 class="mb-1">ผลการจับหน้าล่าสุด</h6>
                <p class="mb-0 text-muted small">เรียงตามคะแนนสูงสุดจากงานนี้</p>
              </div>
              <div class="page-score-chip text-end">
                <div class="text-muted small">หน้าปัจจุบัน</div>
                <div class="page-score-current" id="${cellId}-pageName">-</div>
              </div>
            </div>
            <div class="page-score-body">
              <div id="${cellId}-pageScoresEmpty" class="page-score-empty">ยังไม่มีผลคะแนน</div>
              <div id="${cellId}-pageScoresWrapper" class="table-responsive page-score-table d-none">
                <table id="${cellId}-pageScores" class="table table-striped table-sm mb-0">
                  <thead><tr><th>Page</th><th>Score</th></tr></thead>
                  <tbody id="${cellId}-pageScoresBody"></tbody>
                </table>
              </div>
            </div>
          </div>
          <div class="card roi-card log-card">
            <div class="d-flex align-items-center mb-2 gap-2 menu-select-list">
              <label for="${cellId}-logRoiSelect" class="form-label mb-0">ROI:</label>
              <select id="${cellId}-logRoiSelect" class="form-select w-auto"></select>
            </div>
            <div class="log-wrapper">
              <table id="${cellId}-logTable" class="table table-striped">
                <thead><tr><th>Log</th></tr></thead>
                <tbody id="${cellId}-logBody"></tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="card roi-card roi-list-card">
          <div id="${cellId}-rois" class="roi-grid"></div>
        </div>`;
      inferenceRows.appendChild(row);
      return row;
    }

    function addInferenceRow({ cellId, camId, title, defaultSource, defaultInterval } = {}) {
      let desiredCellId = cellId ? sanitizeCellId(cellId) : '';
      if (desiredCellId) {
        desiredCellId = ensureUniqueCellId(desiredCellId);
        updateNextIndexFromCellId(desiredCellId);
      }
      const actualCellId = desiredCellId || generateCellId();
      const actualCamId = typeof camId === 'string' && camId.length > 0
        ? camId
        : `page_${actualCellId}`;
      const displayTitle = title || `งาน Page Inference ${controllers.size + 1}`;
      createRowElement(actualCellId, displayTitle, actualCamId);
      initRoiLayout(actualCellId);
      const controller = createCameraController(actualCellId, {
        camId: actualCamId,
        title: displayTitle,
        defaultSource,
        defaultInterval,
      });
      controllers.set(actualCellId, controller);
      camIdToCell.set(actualCamId, actualCellId);
      return actualCellId;
    }

    async function removeInferenceRow(cellId) {
      const controller = controllers.get(cellId);
      if (controller && typeof controller.stopInference === 'function') {
        try {
          await controller.stopInference({ force: true, silent: true });
        } catch (err) {
          console.warn('Failed to stop inference before removal', err);
        }
      }
      controllers.delete(cellId);
      if (controller && controller.camId) {
        camIdToCell.delete(controller.camId);
      }
      const row = inferenceRows.querySelector(`.cam-row[data-cell-id="${cellId}"]`);
      if (row) {
        row.remove();
      }
      ['source', 'interval'].forEach(key => localStorage.removeItem(`${cellId}-${key}`));
      showAlert('ลบงาน Inference แล้ว', 'info');
      if (controllers.size === 0) {
        addInferenceRow();
      }
    }

    addButton.addEventListener('click', () => {
      const cellId = addInferenceRow();
      showAlert('สร้างงาน Inference ใหม่แล้ว', 'success');
      const sourceSelect = document.getElementById(`${cellId}-sourceSelect`);
      if (sourceSelect) {
        sourceSelect.focus();
      }
    });

    inferenceRows.addEventListener('click', async event => {
      const button = event.target.closest('[data-action="remove"]');
      if (!button) {
        return;
      }
      const cellId = button.getAttribute('data-cell-id');
      if (!cellId) {
        return;
      }
      const confirmed = window.confirm('ต้องการลบงาน Inference นี้หรือไม่? ระบบจะหยุดการประมวลผลให้ทันที');
      if (!confirmed) {
        return;
      }
      await removeInferenceRow(cellId);
    });

    async function bootstrapExisting() {
      let createdAny = false;
      try {
        const res = await fetch('/api/dashboard');
        if (res.ok) {
          const payload = await res.json();
          const cameras = Array.isArray(payload?.cameras) ? payload.cameras : [];
          cameras
            .filter(cam => (
              typeof cam?.cam_id === 'string'
              && cam.cam_id.startsWith('page_')
              && cam.inference_running
            ))
            .forEach(cam => {
              const camId = cam.cam_id;
              if (camIdToCell.has(camId)) {
                return;
              }
              const rawCell = camId.replace(/^page_/, '') || camId;
              const cellId = addInferenceRow({
                cellId: rawCell,
                camId,
                title: cam.name || camId,
                defaultSource: cam.name || '',
                defaultInterval: cam.interval,
              });
              createdAny = true;
            });
        }
      } catch (err) {
        console.warn('ไม่สามารถโหลดงาน Inference ที่มีอยู่ได้', err);
      }
      if (!createdAny && controllers.size === 0) {
        addInferenceRow();
      }
    }

    bootstrapExisting();
  })();
</script>
