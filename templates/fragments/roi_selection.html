    <style>
        #video { border: 1px solid black; position: relative; }
        #canvas { position: absolute; left: 0; top: 0; }
    </style>
    <select id="sourceSelect"></select>
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="saveBtn">Save All</button>
    <button id="clearBtn">Clear All</button>
    <br><br>
    <div style="position: relative; display: inline-block;">
        <img id="video" />
        <canvas id="canvas"></canvas>
    </div>

    <script>
        (function() {
            let socket;
            let rois = [];
            let currentPoints = [];
            let hoverPoint = null;
            let currentSource = "";
            let initialized = false;
            let isRunning = false;
            const cam = 1;

            const video = document.getElementById("video");
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const saveBtn = document.getElementById('saveBtn');
            const clearBtn = document.getElementById('clearBtn');

            video.onload = () => {
                if (!initialized || canvas.width !== video.naturalWidth || canvas.height !== video.naturalHeight) {
                    canvas.width = video.naturalWidth;
                    canvas.height = video.naturalHeight;
                    canvas.style.width = video.naturalWidth + 'px';
                    canvas.style.height = video.naturalHeight + 'px';
                    initialized = true;
                }
                drawAllRois();
                URL.revokeObjectURL(video.src);
            };

            async function loadSources() {
                const res = await fetch("/source_list");
                const data = await res.json();
                const select = document.getElementById("sourceSelect");
                select.innerHTML = '';
                data.forEach(item => {
                    const opt = document.createElement("option");
                    opt.value = item.name;
                    opt.textContent = item.name;
                    select.appendChild(opt);
                });
                const savedSource = localStorage.getItem('roiSource');
                if (localStorage.getItem('roiStreaming') === 'true' && savedSource) {
                    select.value = savedSource;
                    await startStream();
                }
            }

            async function startStream() {
                if (isRunning) return;
                const name = document.getElementById("sourceSelect").value;
                if (!name) {
                    alert("Select source first");
                    return;
                }
                startBtn.disabled = true;
                currentSource = name;
                const cfg = await fetch(`/source_config?name=${encodeURIComponent(name)}`).then(r => r.json());
                const setRes = await fetch(`/set_camera/${cam}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ name, source: cfg.source })
                });
                if (!setRes.ok) {
                    alert("Failed to set camera");
                    isRunning = false;
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    return;
                }
                const startRes = await fetch(`/start_roi_stream/${cam}`, { method: "POST" });
                if (!startRes.ok) {
                    alert("Failed to start ROI stream");
                    isRunning = false;
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    return;
                }
                socket = new WebSocket(`ws://${location.host}/ws_roi/${cam}`);
                socket.binaryType = "arraybuffer";
                socket.onmessage = function(event) {
                    const blob = new Blob([event.data], { type: "image/jpeg" });
                    video.src = URL.createObjectURL(blob);
                };
                socket.onclose = function() {
                    socket = null;
                    isRunning = false;
                    startBtn.disabled = false;
                    startBtn.innerText = 'Start';
                    stopBtn.disabled = true;
                    localStorage.removeItem('roiStreaming');
                    localStorage.removeItem('roiSource');
                    console.log("ROI stream closed");
                };
                await loadRois();
                isRunning = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                startBtn.innerText = 'Start';
                localStorage.setItem('roiStreaming', 'true');
                localStorage.setItem('roiSource', currentSource);
            }

            function stopStream() {
                if (socket) {
                    socket.close();
                    socket = null;
                }
                try {
                    fetch(`/stop_roi_stream/${cam}`, { method: 'POST', keepalive: true });
                } catch (err) {
                    console.error('Failed to stop ROI stream', err);
                }
                startBtn.innerText = 'Resume';
                startBtn.disabled = false;
                stopBtn.disabled = true;
                isRunning = false;
                localStorage.removeItem('roiStreaming');
                localStorage.removeItem('roiSource');
            }

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                currentPoints.push({ x, y });
                if (currentPoints.length === 4) {
                    const roiId = prompt("ROI id?");
                    if (roiId !== null) {
                        rois.push({ id: roiId, points: [...currentPoints] });
                    }
                    currentPoints = [];
                    hoverPoint = null;
                }
                drawAllRois();
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                hoverPoint = { x, y };
                drawAllRois();
            });

            canvas.addEventListener('mouseleave', () => {
                hoverPoint = null;
                drawAllRois();
            });

            function drawAllRois() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                rois.forEach(r => {
                    if (!r.points || r.points.length === 0) return;
                    ctx.beginPath();
                    ctx.moveTo(r.points[0].x, r.points[0].y);
                    for (let i = 1; i < r.points.length; i++) {
                        ctx.lineTo(r.points[i].x, r.points[i].y);
                    }
                    ctx.closePath();
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    r.points.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = 'blue';
                        ctx.fill();
                    });
                    if (r.id !== undefined) {
                        ctx.font = '16px sans-serif';
                        ctx.fillStyle = 'blue';
                        ctx.fillText(r.id, r.points[0].x, Math.max(10, r.points[0].y - 5));
                    }
                });
                if (currentPoints.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(currentPoints[0].x, currentPoints[0].y);
                    for (let i = 1; i < currentPoints.length; i++) {
                        ctx.lineTo(currentPoints[i].x, currentPoints[i].y);
                    }
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    currentPoints.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = 'red';
                        ctx.fill();
                    });
                    if (hoverPoint) {
                        const last = currentPoints[currentPoints.length - 1];
                        ctx.beginPath();
                        ctx.moveTo(last.x, last.y);
                        ctx.lineTo(hoverPoint.x, hoverPoint.y);
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }

            async function loadRois() {
                if (!currentSource) {
                    rois = [];
                    currentPoints = [];
                    drawAllRois();
                    return;
                }
                const res = await fetch(`/load_roi/${encodeURIComponent(currentSource)}`);
                const data = await res.json();
                rois = data.rois.map((r, idx) => {
                    let pts = r.points;
                    if (!pts && "x" in r && "y" in r && "width" in r && "height" in r) {
                        pts = [
                            { x: r.x, y: r.y },
                            { x: r.x + r.width, y: r.y },
                            { x: r.x + r.width, y: r.y + r.height },
                            { x: r.x, y: r.y + r.height }
                        ];
                    }
                    return {
                        id: r.id ?? String(idx + 1),
                        points: pts || []
                    };
                });
                currentPoints = [];
                drawAllRois();
            }

            function saveAllRois() {
                if (rois.length === 0) {
                    alert("No ROI selected.");
                    return;
                }
                if (!confirm("Save all ROIs?")) return;

                fetch(`/save_roi`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ rois: rois, source: currentSource })
                })
                .then(res => res.json())
                .then(data => {
                    alert("Saved to: " + data.filename);
                    loadRois();
                });
            }

            function clearAllRois() {
                if (rois.length === 0) {
                    alert("No ROI to clear.");
                    return;
                }
                if (!confirm("Clear all ROIs?")) return;

                rois = [];
                currentPoints = [];
                drawAllRois();

                fetch(`/save_roi`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ rois: rois, source: currentSource })
                })
                .then(res => res.json())
                .then(data => {
                    alert("Cleared. Saved to: " + data.filename);
                    loadRois();
                });
            }

            startBtn.addEventListener('click', startStream);
            stopBtn.addEventListener('click', stopStream);
            saveBtn.addEventListener('click', saveAllRois);
            clearBtn.addEventListener('click', clearAllRois);

            function cleanup() {
                try {
                    stopStream();
                } catch (err) {
                    console.error('Cleanup error', err);
                }
            }

            window.startStream = startStream;
            window.stopStream = stopStream;
            window.saveAllRois = saveAllRois;
            window.clearAllRois = clearAllRois;
            window.onFragmentUnload = cleanup;

            loadSources();
        })();
    </script>
