{% extends "base.html" %}
{% block title %}ROI Selection{% endblock %}
{% block content %}

<select id="sourceSelect"></select>
<button id="startBtn">Start</button>
<button id="stopBtn" disabled>Stop</button>
<button id="clearBtn">Clear All</button>

<br><br>
<div class="d-flex">
    <div id="roiToolbar" class="btn-group-vertical me-2">
        <button id="pickBtn" class="btn btn-primary">Pick Points</button>
        <button id="rectBtn" class="btn btn-secondary">Rectangle</button>
    </div>
    <div id="frameContainer" style="position: relative; display: inline-block;">
        <img id="video" />
        <canvas id="canvas"></canvas>
    </div>
</div>

<div id="roiList"></div>

<script>
    (function() {
        let socket;
        let rois = [];
        let currentPoints = [];
        let hoverPoint = null;

        let rectStart = null;
        let rectEnd = null;
        let drawingRect = false;
        let currentMode = 'points';

        let currentSource = "";
        let groups = [];
        let modules = [];
        let initialized = false;
        let isStreaming = false;
        let hasStarted = false;
        const cam = 1;

        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const frameContainer = document.getElementById("frameContainer");
        const ctx = canvas.getContext("2d");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const pickBtn = document.getElementById("pickBtn");
        const rectBtn = document.getElementById("rectBtn");

        function setMode(mode) {
            currentMode = mode;
            if (mode === 'points') {
                pickBtn.classList.add('btn-primary');
                pickBtn.classList.remove('btn-secondary');
                rectBtn.classList.add('btn-secondary');
                rectBtn.classList.remove('btn-primary');
            } else {
                rectBtn.classList.add('btn-primary');
                rectBtn.classList.remove('btn-secondary');
                pickBtn.classList.add('btn-secondary');
                pickBtn.classList.remove('btn-primary');
            }
            currentPoints = [];
            rectStart = null;
            rectEnd = null;
            drawingRect = false;
            hoverPoint = null;
            drawAllRois();
        }

        pickBtn.addEventListener('click', () => setMode('points'));
        rectBtn.addEventListener('click', () => setMode('rect'));

        video.onload = () => {
            if (!initialized || canvas.width !== video.naturalWidth || canvas.height !== video.naturalHeight) {
                canvas.width = video.naturalWidth;
                canvas.height = video.naturalHeight;
                canvas.style.width = video.naturalWidth + 'px';
                canvas.style.height = video.naturalHeight + 'px';
                frameContainer.style.width = video.naturalWidth + 'px';
                frameContainer.style.height = video.naturalHeight + 'px';
                initialized = true;
            }
            drawAllRois();
            URL.revokeObjectURL(video.src);
        };

        async function loadSources() {
            const res = await fetch("/source_list");
            const data = await res.json();
            const select = document.getElementById("sourceSelect");
            select.innerHTML = '';

            data.forEach(item => {
                const opt = document.createElement("option");
                opt.value = item.name;
                opt.textContent = item.name;
                select.appendChild(opt);
            });
        }

        // Load available groups from server (if any)
        async function loadGroups() {
            try {
                const res = await fetch('/groups');
                if (!res.ok) throw new Error('Bad response');
                groups = await res.json();
            } catch (err) {
                console.error('Failed to load groups', err);
                groups = [];
            }
            renderRoiList();
        }

        // Load available inference modules from server
        async function loadModules() {
            try {
                const res = await fetch('/inference_modules');
                if (!res.ok) throw new Error('Bad response');
                modules = await res.json();
            } catch (err) {
                console.error('Failed to load inference modules', err);
                modules = [];
            }
            renderRoiList();
        }

        function openSocket() {
            socket = new WebSocket(`ws://${location.host}/ws_roi/${cam}`);
            socket.binaryType = "arraybuffer";
            socket.onmessage = function(event) {
                const blob = new Blob([event.data], { type: "image/jpeg" });
                video.src = URL.createObjectURL(blob);
            };
            socket.onclose = function() {
                socket = null;
                isStreaming = false;
                stopBtn.disabled = true;
                startBtn.disabled = false;
                hasStarted = false;
                console.log("ROI stream closed");
            };
        }

        async function checkStatus() {
            const res = await fetch(`/roi_stream_status/${cam}`);
            const data = await res.json();
            if (data.running) {
                const select = document.getElementById("sourceSelect");
                if (data.source) {
                    select.value = data.source;
                    currentSource = data.source;
                    await loadRois();
                }
                openSocket();
                isStreaming = true;
                startBtn.disabled = true;
                startBtn.textContent = "Start";
                stopBtn.disabled = false;
                setMode('points');
            } else {
                startBtn.disabled = false;
                startBtn.textContent = "Start";
                stopBtn.disabled = true;
            }
        }

        async function startStream() {
            if (hasStarted) return;
            if (isStreaming) return;
            hasStarted = true;
            const name = document.getElementById("sourceSelect").value;
            if (!name) {
                if (typeof showAlert === 'function') showAlert('Select source first', 'error');
                return;
            }
            startBtn.disabled = true;
            currentSource = name;
            const cfg = await fetch(`/source_config?name=${encodeURIComponent(name)}`).then(r => r.json());
            const { module, ...cfgNoModule } = cfg;
            const setRes = await fetch(`/set_camera/${cam}`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(cfgNoModule)
            });
            if (!setRes.ok) {
                if (typeof showAlert === 'function') showAlert('Failed to set camera', 'error');
                isStreaming = false;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                return;
            }
            const startRes = await fetch(`/start_roi_stream/${cam}`, { method: "POST" });
            if (!startRes.ok) {
                if (typeof showAlert === 'function') showAlert('Failed to start ROI stream', 'error');
                isStreaming = false;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                return;
            }
            openSocket();
            await loadRois();
            isStreaming = true;
            stopBtn.disabled = false;
            startBtn.textContent = "Start";
        }

        async function stopStream() {
            if (socket) {
                socket.close();
                socket = null;
            }
            try {
                await fetch(`/stop_roi_stream/${cam}`, { method: 'POST', keepalive: true });
            } catch (err) {
                console.error('Failed to stop ROI stream', err);
            }
            isStreaming = false;
            hasStarted = false;
            stopBtn.disabled = true;
            startBtn.disabled = false;
        }

        frameContainer.addEventListener('click', (e) => {
            const rect = frameContainer.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (currentMode === 'points') {
                currentPoints.push({ x, y });
                if (currentPoints.length === 4) {
                    const roiId = prompt("ROI id?");
                    if (roiId !== null) {
                        const groupId = prompt("Group id?");
                        rois.push({
                            id: roiId,
                            group: groupId,
                            module: "",
                            points: currentPoints.slice()
                        });
                        renderRoiList();
                        fetch('/save_roi', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ rois: rois, source: currentSource })
                        });
                    }
                    currentPoints = [];
                }
            } else if (currentMode === 'rect') {
                if (!rectStart) {
                    rectStart = { x, y };
                    drawingRect = true;
                } else if (drawingRect) {
                    rectEnd = { x, y };
                    const x1 = Math.min(rectStart.x, rectEnd.x);
                    const y1 = Math.min(rectStart.y, rectEnd.y);
                    const x2 = Math.max(rectStart.x, rectEnd.x);
                    const y2 = Math.max(rectStart.y, rectEnd.y);
                    const points = [
                        { x: x1, y: y1 },
                        { x: x2, y: y1 },
                        { x: x2, y: y2 },
                        { x: x1, y: y2 }
                    ];
                    const roiId = prompt("ROI id?");
                    if (roiId !== null) {
                        const groupId = prompt("Group id?");
                        rois.push({ id: roiId, group: groupId, module: "", points });
                        renderRoiList();
                        fetch('/save_roi', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ rois: rois, source: currentSource })
                        });
                    }
                    rectStart = null;
                    rectEnd = null;
                    drawingRect = false;
                }
            }
            drawAllRois();
        });

        frameContainer.addEventListener('mousemove', (e) => {
            const rect = frameContainer.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            if (currentMode === 'rect' && drawingRect && rectStart) {
                hoverPoint = {
                    x: Math.max(rectStart.x, x),
                    y: Math.max(rectStart.y, y)
                };
            } else if (currentMode === 'points' && currentPoints.length > 0) {
                hoverPoint = { x, y };
            } else {
                hoverPoint = null;
            }
            drawAllRois();
        });

        frameContainer.addEventListener('mouseleave', () => {
            hoverPoint = null;
            if (currentMode === 'rect' && drawingRect) {
                drawingRect = false;
                rectStart = null;
            }
            drawAllRois();
        });

        function drawAllRois() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            rois.forEach(r => {
                if (!r.points || r.points.length === 0) return;
                ctx.beginPath();
                ctx.moveTo(r.points[0].x, r.points[0].y);
                for (let i = 1; i < r.points.length; i++) {
                    ctx.lineTo(r.points[i].x, r.points[i].y);
                }
                ctx.closePath();
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();
                r.points.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'blue';
                    ctx.fill();
                });
                if (r.id !== undefined) {
                    ctx.font = '16px sans-serif';
                    ctx.fillStyle = 'blue';
                    ctx.fillText(r.id, r.points[0].x, Math.max(10, r.points[0].y - 5));
                }
            });
            if (currentPoints.length > 0) {
                ctx.beginPath();
                ctx.moveTo(currentPoints[0].x, currentPoints[0].y);
                for (let i = 1; i < currentPoints.length; i++) {
                    ctx.lineTo(currentPoints[i].x, currentPoints[i].y);
                }
                if (hoverPoint && !drawingRect) {
                    ctx.lineTo(hoverPoint.x, hoverPoint.y);
                }

                ctx.strokeStyle = 'red';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                currentPoints.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                });
            }
            if (drawingRect && rectStart && hoverPoint) {
                const x = Math.min(rectStart.x, hoverPoint.x);
                const y = Math.min(rectStart.y, hoverPoint.y);
                const w = Math.abs(hoverPoint.x - rectStart.x);
                const h = Math.abs(hoverPoint.y - rectStart.y);
                ctx.save();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, w, h);
                ctx.restore();
            }
            if (drawingRect && rectStart) {
                const end = hoverPoint || rectStart;
                ctx.beginPath();
                ctx.rect(rectStart.x, rectStart.y, end.x - rectStart.x, end.y - rectStart.y);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function renderRoiList() {
            const container = document.getElementById('roiList');
            if (!container) return;
            container.innerHTML = '';

            if (rois.length === 0) return;

            const table = document.createElement('table');
            table.className = 'table table-striped table-sm';
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            ['ID', 'x', 'y', 'w', 'h', 'Group', 'Inference Module', 'Delete'].forEach(col => {
                const th = document.createElement('th');
                th.textContent = col;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            rois.forEach((r, idx) => {
                const xs = r.points.map(p => p.x);
                const ys = r.points.map(p => p.y);
                const x = Math.min(...xs);
                const y = Math.min(...ys);
                const w = Math.max(...xs) - x;
                const h = Math.max(...ys) - y;
                const tr = document.createElement('tr');
                const idTd = document.createElement('td');
                idTd.textContent = r.id;
                tr.appendChild(idTd);
                [x, y, w, h].forEach(val => {
                    const td = document.createElement('td');
                    td.textContent = Math.round(val);
                    tr.appendChild(td);
                });
                const tdGroup = document.createElement('td');
                const input = document.createElement('input');
                input.className = 'form-control form-control-sm';
                input.value = r.group || '';
                input.addEventListener('change', e => updateRoiGroup(idx, e.target.value));
                tdGroup.appendChild(input);
                tr.appendChild(tdGroup);

                const tdModule = document.createElement('td');
                const select = document.createElement('select');
                select.className = 'form-select form-select-sm';
                const blank = document.createElement('option');
                blank.value = '';
                blank.textContent = '';
                select.appendChild(blank);
                modules.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m;
                    opt.textContent = m;
                    if (r.module === m) opt.selected = true;
                    select.appendChild(opt);
                });
                select.addEventListener('change', e => updateRoiModule(idx, e.target.value));
                tdModule.appendChild(select);
                tr.appendChild(tdModule);

                const tdDel = document.createElement('td');
                const delBtn = document.createElement('button');
                delBtn.textContent = 'Delete';
                delBtn.className = 'btn btn-danger btn-sm';
                delBtn.addEventListener('click', () => deleteRoi(idx));
                tdDel.appendChild(delBtn);
                tr.appendChild(tdDel);
                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            container.appendChild(table);
        }

        async function loadRois() {
            if (!currentSource) {
                rois = [];
                currentPoints = [];
                drawAllRois();
                return;
            }
            const res = await fetch(`/load_roi/${encodeURIComponent(currentSource)}`);
            const data = await res.json();
            rois = data.rois.map((r, idx) => {
                let pts = r.points;
                if (!pts && "x" in r && "y" in r && "width" in r && "height" in r) {
                    pts = [
                        { x: r.x, y: r.y },
                        { x: r.x + r.width, y: r.y },
                        { x: r.x + r.width, y: r.y + r.height },
                        { x: r.x, y: r.y + r.height }
                    ];
                }
                return {
                    id: r.id ?? String(idx + 1),
                    group: r.group ?? null,
                    module: r.module ?? "",
                    points: pts || []
                };
            });
            currentPoints = [];
            drawAllRois();
            renderRoiList();
        }

        function clearAllRois() {
            if (rois.length === 0) {
                if (typeof showAlert === 'function') showAlert('No ROI to clear', 'error');
                return;
            }
            if (!confirm("Clear all ROIs?")) return;

            rois = [];
            currentPoints = [];
            drawAllRois();
            renderRoiList();

            fetch(`/save_roi`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ rois: rois, source: currentSource })
            })
            .then(res => res.json())
            .then(data => {
                if (typeof showAlert === 'function') showAlert('Cleared. Saved to: ' + data.filename, 'success');
                loadRois();
            });
        }

        function updateRoiGroup(i, group) {
            rois[i].group = group;
            fetch('/save_roi', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rois: rois, source: currentSource })
            });
        }

        function updateRoiModule(i, module) {
            rois[i].module = module;
            fetch('/save_roi', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rois: rois, source: currentSource })
            });
        }

        function deleteRoi(i) {
            if (!confirm('Delete this ROI?')) return;
            rois.splice(i, 1);
            drawAllRois();
            renderRoiList();

            fetch(`/save_roi`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rois: rois, source: currentSource })
            })
            .then(res => res.json())
            .then(data => {
                if (typeof showAlert === 'function') showAlert('Deleted. Saved to: ' + data.filename, 'success');
            });

        }

        startBtn.addEventListener('click', startStream);
        stopBtn.addEventListener('click', stopStream);
        document.getElementById('clearBtn').addEventListener('click', clearAllRois);

        window.startStream = startStream;
        window.stopStream = stopStream;
        window.clearAllRois = clearAllRois;
        window.updateRoiGroup = updateRoiGroup;
        window.updateRoiModule = updateRoiModule;
        window.deleteRoi = deleteRoi;

        window.addEventListener('beforeunload', () => {
            stopStream();
        });

        setMode('points');

        (async () => {
            await loadSources();
            await loadGroups();
            await loadModules();
            await checkStatus();
            if (typeof showAlert === 'function') showAlert('ROI selection ready', 'success');
        })();
    })();
</script>
{% endblock %}
