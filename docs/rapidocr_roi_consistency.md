# ทำไม RapidOCR อ่าน ROI เดิมซ้ำแล้วผลไม่เหมือนเดิม?

เมื่อตัด ROI จากวิดีโอเฟรมด้วยโค้ดประมาณนี้

```python
roi = frame[y1:y2, x1:x2]
text, _ = rapid_ocr(roi)
```

`roi` ไม่ได้เป็นสำเนาของภาพจริง ๆ แต่เป็น *view* ที่แชร์บัฟเฟอร์ข้อมูลร่วมกับตัวแปร `frame` (นี่เป็นพฤติกรรมปกติของ NumPy/OpenCV เมื่อทำ slice แบบนี้)

ลูปถัดไปตัวแปร `frame` จะถูกแทนที่ด้วยเฟรมใหม่ ทำให้ข้อมูลในบัฟเฟอร์เปลี่ยนตามไปด้วย `roi` จึงเปลี่ยนโดยอัตโนมัติ ถึงแม้เรายังอ้างถึงตัวแปรเดิมอยู่ ผลลัพธ์ OCR จึงไม่นิ่ง เพราะ RapidOCR ได้ภาพใหม่ทุกครั้ง

## วิธีแก้

สร้างสำเนาจริงของ ROI ก่อนส่งเข้า OCR

```python
roi = frame[y1:y2, x1:x2].copy()
text, _ = rapid_ocr(roi)
```

`.copy()` จะสร้างอาร์เรย์ใหม่ที่ก๊อปปี้ค่าพิกเซล ณ เฟรมปัจจุบันไว้ทั้งหมด ดังนั้น RapidOCR จะเห็นภาพเดียวกับที่ตาเราเห็นในรอบนั้น แม้เฟรมถัดไปจะถูกอ่านเข้ามาแล้วข้อมูลใน `frame` เปลี่ยนไปก็ตาม หรือถ้าใช้โค้ดอื่นที่ส่ง ROI เข้า thread/background ก็ต้องสำเนาภาพให้เรียบร้อยก่อน เพราะ view ที่แชร์บัฟเฟอร์จะเปลี่ยนตามต้นฉบับเสมอ นอกจากนี้ในโค้ดหลักยังมีการล็อกไม่ให้ RapidOCR ทำงานพร้อมกันหลายเธรดและบังคับให้ภาพเป็น contiguous ก่อนเข้าโมดูลเพื่อป้องกันผล OCR แกว่งเมื่อมีคำขอพร้อมกันหลายคำขอ

## เช็กได้อย่างไรว่าเป็นเพราะ view?

1. ลองพิมพ์ `roi.base is frame` (หรือใช้ `np.may_share_memory`) จะพบว่าค่าขึ้น `True`
2. ถ้าพิมพ์ `id(roi.data)` แล้ววนลูปหลายรอบจะได้ค่าเดียวกัน แสดงว่าแชร์บัฟเฟอร์อยู่
3. เมื่อใช้ `.copy()` จะได้ `roi.base is None` และ `id(roi.data)` เปลี่ยน หมายถึงมีสำเนาใหม่จริง ๆ

สรุป: ให้สร้างสำเนาของ ROI ทุกครั้งก่อนส่งเข้า RapidOCR หากต้องการผลลัพธ์ OCR เดิมซ้ำได้
